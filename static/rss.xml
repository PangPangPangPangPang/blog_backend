<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Max&#39;s Blog</title>
    <link>https://mmmmmax.cn</link>
    <description>分享一下自己乱七八糟的生活</description>
    <managingEditor>im.yf.wang@gmail.com (Max)</managingEditor>
    <pubDate>Sun, 31 Mar 2019 17:47:26 +0800</pubDate>
    <item>
      <title>使用Taskwarrior管理你的todolist</title>
      <link>https://mmmmmax.cn/#list/ffd6a93270fad278526adc0ec678afc2</link>
      <description>&lt;h1&gt;使用Taskwarrior管理你的todolist&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;写在前面：其实自己原来并没有一个记录&lt;strong&gt;Todolist&lt;/strong&gt;的习惯，真是挺抱歉没有及早的养成一个好习惯。最近领导任命我为组长&lt;del&gt;狗腿子&lt;/del&gt;有意让我去负责一些管理的事情，其实我很早就表态过不希望做这些杂七杂八的事情，尽管给我安排需求就可以了，然而领导还是让我分配了不喜欢的工作,怨念！&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;既然作为一个管理者，必须合理的安排自己的事情，这时候就需要一个&lt;strong&gt;Todolist&lt;/strong&gt;来帮助你规划事项。经过一系列选型（装逼为主），最终选用了这个终端工具：&lt;strong&gt;Taskwarrior&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然了本文主要是用来安利&lt;del&gt;备忘&lt;/del&gt;的，如果你是一个自身Geek，那么根据你的系统安装后即可关闭本篇文章。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yay -S task&#xA;man task&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;好啦，正式进入正文！&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 基础命令构成&#xA;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; [ &amp;lt;mods&amp;gt; | &amp;lt;args&amp;gt; ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;task&lt;/strong&gt;：顾名思义，就是主命令啦！&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;：顾名思义，就是filter啦！开个玩笑，这个位置可以加一些限定条件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;task project:Home list # 限定工作区&#xA;task project:Home +weekend garden list  # +weekend为限定标签， graden为模糊匹配&#xA;task project:Home due.before:today # due.before:today为今天之前&#xA;task 28 # 28为task的ID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;mods&lt;/strong&gt;: 顾名思义（能不能少用这个词），指定task的属性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; project:Home&#xA;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; +weekend +garden due:tomorrow&#xA;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; Description/annotation text&#xA;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; /from/to/     &amp;lt;- replace first match&#xA;task &amp;lt;filter&amp;gt; &amp;lt;command&amp;gt; /from/to/g    &amp;lt;- replace all matches&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;command&lt;/strong&gt;：&lt;strong&gt;command&lt;/strong&gt;就太多了，其中的&lt;strong&gt;read subcommands&lt;/strong&gt;建议自己用&lt;strong&gt;man&lt;/strong&gt;去看，我这里记录几个常用的命令。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Read subcommands&#xA;task &amp;lt;filter&amp;gt; # 展示相关task&#xA;task &amp;lt;filter&amp;gt; active/all/blocked/completed/newest&#xA;task commands # 速查&#xA;task canlendar&#xA;&#xA;# Write subcommands&#xA;task add &amp;lt;mods&amp;gt; # 添加task&#xA;task &amp;lt;filter&amp;gt; start &amp;lt;mods&amp;gt; # 开始task&#xA;task &amp;lt;filter&amp;gt; stop &amp;lt;mods&amp;gt; # 结束task&#xA;task &amp;lt;filter&amp;gt; annotate &amp;lt;mods&amp;gt; # 为task添加注释&#xA;task &amp;lt;filter&amp;gt; denotate &amp;lt;mods&amp;gt; # 为task删除注释&#xA;task &amp;lt;filter&amp;gt; append &amp;lt;mods&amp;gt; # 为task补充信息&#xA;task &amp;lt;filter&amp;gt; delete &amp;lt;mods&amp;gt; # 删除指定task&#xA;task &amp;lt;filter&amp;gt; done &amp;lt;mods&amp;gt; # 标注指定task完成&#xA;task &amp;lt;filter&amp;gt; edit # 用编辑器编辑指定task&#xA;task &amp;lt;filter&amp;gt; modify &amp;lt;mods&amp;gt; # 用编辑指定task&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;attributes&lt;/strong&gt;：task的属性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;+&amp;lt;tag&amp;gt; # 添加标签&#xA;project:&amp;lt;project-name&amp;gt; # 工作区名称&#xA;priority:H|M|L # 优先级&#xA;due:&amp;lt;due-date&amp;gt; # 到期日期&#xA;depends:&amp;lt;id1,id2&amp;gt; # 指定依赖的task（需要在指定task后开始）&#xA;recur:&amp;lt;frequency&amp;gt; # day/month 等指定循环频率，用于设置周期性任务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;attributes modifiers&lt;/strong&gt;：属性的修饰符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;before (synonyms under, below)&#xA;after (synonyms over, above)&#xA;none&#xA;any&#xA;is (synonym equals)&#xA;isnt (synonym not)&#xA;has (synonym contains)&#xA;hasnt&#xA;startswith (synonym left)&#xA;endswith (synonym right)&#xA;word&#xA;noword&#xA;&#xA;# demo&#xA;task due.before:eom priority.not:L list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt;：特别强调一下due的描述&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;due:2019-03-21&#xA;due:now&#xA;due:today&#xA;due:yesterday&#xA;due:tomorrow&#xA;due:23rd&#xA;due:3wks&#xA;due:1day&#xA;due:9hrs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;同步&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实用&lt;a href=&#34;https://inthe.am/&#34;&gt;inthe.am&lt;/a&gt;生成3个密钥，并离线保存好。&lt;/li&gt;&#xA;&lt;li&gt;在&lt;strong&gt;~/.taskrc&lt;/strong&gt;文件中添加如下内容(当然了这些设置都可以在&lt;a href=&#34;https://inthe.am/configure&#34;&gt;inthe.am&lt;/a&gt;)中找到。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;taskd.certificate=/path/to/private.certificate.pem&#xA;taskd.key=/path/to/private.key.pem&#xA;taskd.ca=/path/to/ca.cert.pem&#xA;taskd.server=taskwarrior.inthe.am:53589&#xA;taskd.credentials=&amp;lt;your credentials&amp;gt;&#xA;taskd.trust=ignore hostname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行&lt;strong&gt;task sync init&lt;/strong&gt;进行初始化。&lt;/li&gt;&#xA;&lt;li&gt;正常执行添加task等操作。&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;strong&gt;task sync&lt;/strong&gt;将本地修改同步到云端。（从云端将内容同步到本地也是用这个命令）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
      <pubDate>Wed, 20 Mar 2019 22:04:11 +0000</pubDate>
    </item>
    <item>
      <title>让笔记本重焕新生</title>
      <link>https://mmmmmax.cn/#list/166170bedd021f50ff87045813edcd2d</link>
      <description>&lt;h1&gt;让笔记本重焕新生&lt;/h1&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;要说如何让一个3年前的笔记本重焕新生，只需如下几个步骤&#xA;1. 给你的笔记本装一个固态硬盘&#xA;2. 给你的笔记本装一个轻量级的liunx发新版（&lt;strong&gt;Manjaro&lt;/strong&gt;划重点）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这篇博客简单分享一下换固态硬盘的过程。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;开工&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是狗东上买到的大号U盘，其实最后使用下来体验还是不错的，一块钱1G的价格还要求什么呢，希望不要很快翻车吧。&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1fzpsjizjxdj20qo0zk0z2.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后晒一下拆机前的合影，除我家蠢猫外，其他均为摆拍。里面包括一个老本儿，一块固态硬盘，一盒螺丝刀工具，一个光驱位硬盘托架，一对JoyCon，一只ProCon，一盒卡带，两个凳子，一盒口罩，一个&lt;del&gt;泡脚盆&lt;/del&gt;,一只乱入的蠢猫。（十几块钱买的螺丝刀工具箱是真滴好用啊！）&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1fzpsjiywiqj20zk0qoad9.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后是拆开后盖后的照片，我这个本子的用料还是挺足的，最起码后盖不是塑料的。。&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1fzpsjizvygj20zk0qon29.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接着就要把机械硬盘跟光驱拆下来，记得螺丝分类归纳好。这里因为无线网卡跟光驱位置很接近，拆的时候不小心把无线网卡碰的接触不良，导致后来装机折腾了了很久。&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1fzpsjj08a5j20zk0qon28.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后就是安装好的照片啦，上一步卸下来之后，把固态硬盘放回到原来机械硬盘的位置，然后把机械硬盘装到光驱位硬盘托架上，最后装到光驱位。装好螺丝，搞定！&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1fzpsjj0bm2j20zk0qo0y5.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;后记&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;其实整个换硬盘的过程还是很顺利的，老笔记本的模块化做的都还不错。最坑的是把无线网卡碰松了之后，导致我后续装机的时候老是搜索不到wifi，最最坑的是有时候能搜到，有时候搜不到。导致我像一个傻缺QA一样，整个晚上都在查复现路径还以为是镜像的问题！&#xA;还好第二天早上群友提醒我有可能是没插好，最终才解决这个问题！&lt;/p&gt;&#xA;</description>
      <pubDate>Mon, 18 Feb 2019 03:46:36 +0000</pubDate>
    </item>
    <item>
      <title>从头开始折腾Manjaro</title>
      <link>https://mmmmmax.cn/#list/6c1ccdc3b7167ddba41bcea86deb0a16</link>
      <description>&lt;h1&gt;从头开始折腾Manjaro&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;前几天入了块超便宜的固态硬盘，装上操作系统后让我这个14年的老笔记本彻底复活！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是不尽如人意的是装上之后发现&lt;code&gt;/&lt;/code&gt;分区分的磁盘空间太小惹。看了看改逻辑分区的工具&lt;code&gt;lvm&lt;/code&gt;操作实在有些&lt;del&gt;麻烦&lt;/del&gt;让人懒得看，还是重新装一下系统吧。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装操作系统&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://manjaro.org/download/i3/&#34;&gt;官网&lt;/a&gt;下载官方镜像，这里选择的i3wm的版本，没别的原因，好用就对了！&lt;/li&gt;&#xA;&lt;li&gt;插上U盘开始flash镜像，这里推荐个&lt;a href=&#34;https://etcher.io/&#34;&gt;工具&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;重启狂按某个&lt;strong&gt;神秘按键&lt;/strong&gt;进入到电脑的&lt;strong&gt;bios&lt;/strong&gt;并选择你的U盘来启动。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Manajo&lt;/strong&gt;官方提供的镜像安装操作系统很方便，基本一路点点点就可以了。这里备注一下如何分区&#xA;&lt;code&gt;&#xA;/boot      256M&#xA;/          100G&#xA;/swap      10G&#xA;/home/user 剩下的&#xA;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;配置的时候遇到了很多坑，想想之前其实都遇到过了，只是没有记录下来，导致又重新趟了一遍。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;初始配置中的一些坑&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Manjaro-i3&lt;/strong&gt;默认用的是&lt;strong&gt;Alsa&lt;/strong&gt;管理音频，这在我的本子上根本不好使，敲一下&lt;strong&gt;mod+ctrl+h 或者 mod+shift+h&lt;/strong&gt;打开帮助文档。可以看到在终端运行&lt;strong&gt;install_pulse&lt;/strong&gt;就可以安装熟悉的&lt;strong&gt;Pulseaudio&lt;/strong&gt;来管理音频了。(这个帮助文档里也有一些基本的i3操作)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是不知道是不是我电脑的硬件不兼容的问题，导致启动之后是没有声音的，必须kill掉&lt;strong&gt;Pulseaudio&lt;/strong&gt;并重启才能开启声音，所以需要在i3的配置文件中配置开机先杀掉再启动。文件在&lt;a href=&#34;https://github.com/PangPangPangPangPang/dotfiles/blob/master/default_config&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;del&gt;其实还有一个坑，就是偶尔wireless无效！最开始以为是无线网卡驱动的问题，查了半天，最后发现是没有插好！！！&lt;/del&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;正经的初始配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;先换中国源&lt;strong&gt;sudo pacman-mirrors -i -c China -m rank&lt;/strong&gt; 。&#xA;然后不管三七二十一，先跑一遍&lt;strong&gt;sudo pacman -Syyu&lt;/strong&gt;滚一下软件包，结束后重启。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;AUR支持&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_User_Repository&#34;&gt;Arch User Repository&lt;/a&gt; （常被称作 AUR），是一个为 Arch 用户而生的社区驱动软件仓库。Debian/Ubuntu 用户的对应类比是 PPA。&#xA;官方的&lt;strong&gt;pacman&lt;/strong&gt;只支持安装官方背书包，所以需要一个工具支持安装&lt;strong&gt;AUR&lt;/strong&gt;中的包。&#xA;其实我一开始都是用的&lt;strong&gt;yaourt&lt;/strong&gt;，但是在官方文档中已经被标注为不推荐使用了。那就换&lt;a href=&#34;https://github.com/Jguer/yay&#34;&gt;yay&lt;/a&gt;好了，名字还更好记一点。下面是安装命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://aur.archlinux.org/yay.git&#xA;cd yay&#xA;makepkg -si&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;终端&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;习惯用&lt;strong&gt;kitty&lt;/strong&gt;跟&lt;strong&gt;zsh&lt;/strong&gt;就还是用它们就好了&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# ~/.config/kitty/kitty.conf&#xA;yay -S kitty&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo pacman -S terminator zsh&#xA;&#xA;#顺便装上oh-my-zsh&#xA;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;输入法&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;习惯用&lt;strong&gt;fcitx&lt;/strong&gt;了，其实也没什么别的选择。（= =）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo pacman -S fcitx-googlepinyin&#xA;sudo pacman -S fcitx-im             &#xA;sudo pacman -S fcitx-configtool    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后在&lt;code&gt;~/.xprofile&lt;/code&gt;文件里面加上&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GTK_IM_MODULE=fcitx&#xA;export QT_IM_MODULE=fcitx&#xA;export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后重启下&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;屏幕分辨率&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# ~./.Xresource&#xA;# Refresh: xrdb -merge .Xresources&#xA;&#xA;Xft.dpi: 108&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;默认程序修改&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在&lt;code&gt;.config/mimeapps.list&lt;/code&gt;文件中编辑默认程序。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;常用应用&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件管理器：&lt;strong&gt;pcmanfm&lt;/strong&gt;(Manjaro-i3 自带)&lt;/li&gt;&#xA;&lt;li&gt;邮件：&lt;strong&gt;mailsprint&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;词典：&lt;strong&gt;ydcv&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;快捷启动器：&lt;strong&gt;rofi&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # Add in ~/.i3/config&#xA;  bindsym $mod+p exec rofi -show combi&#xA;  # 在rofi中启动ydcv&#xA;  bindsym $mod+t exec rofi -modi ydcv:&#39;ydcv&#39; -show ydcv&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;桌面图片管理：&lt;strong&gt;nitrogen&lt;/strong&gt;(Manjaro-i3 自带)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # Add in ~/.i3/config&#xA;  exec_always --no-startup-id nitrogen --set-zoom ~/img/background.jpg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;浏览器：&lt;strong&gt;google-chrome&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;音乐播放器：&lt;strong&gt;mocp&lt;/strong&gt;(Manjaro-i3 自带)、&lt;strong&gt;spotify&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;开始菜单：&lt;strong&gt;morc_menu&lt;/strong&gt;(Manjaro-i3 自带, &lt;code&gt;mod+z&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;通用菜单：&lt;strong&gt;bmenu&lt;/strong&gt;(Manjaro-i3 自带, &lt;code&gt;mod+ctrl+b&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;investigate socket: &lt;strong&gt;&lt;em&gt;ss&lt;/em&gt;&lt;/strong&gt;(代替netstat)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;写在最后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Manjaro天下第一！&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
      <pubDate>Sat, 26 Jan 2019 11:43:36 +0000</pubDate>
    </item>
    <item>
      <title>重新鼓捣博客</title>
      <link>https://mmmmmax.cn/#list/952861ab331c96a02e2214ee88324618</link>
      <description>&lt;h1&gt;重新鼓捣博客&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;想想上次折腾博客已经是两年前的事情了。后来忙于工作（摸鱼）就没有继续维护了。这次也不知道为了啥想把我这年久失修的博客重新跑起来，其实总共包括三件事情。&#xA;1. 重新跑起来后端服务，顺便加上了更新文章的能力。（以前都是要重新上vps手动更新，是在太low了！！！）&#xA;2. 更新前端各种依赖包。（由于之前用的react技术栈，前端圈子的更新真的是跟不上，之前也是直接锁本了。再捡起来项目的时候发现已经跑不起来了，索性就用&lt;code&gt;create-react-app&lt;/code&gt;重新构建了项目）&#xA;3. 优化了Markdown文件的解析。（其实就是之前偷懒没有好好写，这次&lt;del&gt;像素级抄袭&lt;/del&gt;借鉴github的README重新优化了下，效果不错有了更好的体验）&#xA;4. 把整个项目部署放到docker里（也就是上篇文章做的事情，docker入门之后真的方便。）&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;后端&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;重新跑后端就不记录了，之前作死用的&lt;code&gt;flask+virtualenv+nginx&lt;/code&gt;事实证明不是一个很好的选择，首先是&lt;strong&gt;python&lt;/strong&gt;代码不是很容易维护，当初为了玩&lt;strong&gt;python&lt;/strong&gt;用了各种语法糖跟各种特性魔法，导致我现在也不是很能看懂了。还有个很严重的问题是我已经完全忘了该怎么本地调试代码了！！！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;前端&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;前端的迁移比想象中的轻松很多，是个愉快的过程。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;迁移&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用&lt;code&gt;create-react-app&lt;/code&gt;构建脚手架应用。&lt;/li&gt;&#xA;&lt;li&gt;把之前用的依赖库加到&lt;code&gt;package.json&lt;/code&gt;文件中。（其实是一个个install的，毕竟要更新依赖库）&lt;/li&gt;&#xA;&lt;li&gt;把旧仓库的源码粘贴到新仓库，然后根据报错开始适配。（编码环境用的这个&lt;a href=&#34;https://github.com/neoclide/coc.nvim&#34;&gt;插件&lt;/a&gt;,强烈推荐&lt;strong&gt;neovim&lt;/strong&gt;用户使用！)&lt;/li&gt;&#xA;&lt;li&gt;代码编译过去之后，发现&lt;strong&gt;svg&lt;/strong&gt;不好用了，因为之前配置&lt;strong&gt;babel&lt;/strong&gt;的&lt;strong&gt;loader&lt;/strong&gt;在编译期把&lt;strong&gt;svg&lt;/strong&gt;文件转成&lt;strong&gt;React&lt;/strong&gt;组件，不过这个脚手架应用配置&lt;strong&gt;loader&lt;/strong&gt;不是很方便。于是找到&lt;a href=&#34;https://github.com/smooth-code/svgr&#34;&gt;这个东西&lt;/a&gt;，手动转换一下。&lt;/li&gt;&#xA;&lt;li&gt;优化&lt;strong&gt;Markdown&lt;/strong&gt;解析，主要优化点：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;美化了&lt;strong&gt;blockquote&lt;/strong&gt;。（必须得说以前的太丑了，我是怎么忍受的！）&lt;/li&gt;&#xA;&lt;li&gt;优化了&lt;strong&gt;code&lt;/strong&gt;。（该成了浅色背景，看起来跟和谐）&lt;/li&gt;&#xA;&lt;li&gt;给&lt;strong&gt;header&lt;/strong&gt;加了下分割线。（借鉴了&lt;strong&gt;github&lt;/strong&gt;，看起来跟整齐有条例）&lt;/li&gt;&#xA;&lt;li&gt;修正了&lt;strong&gt;image&lt;/strong&gt;的展现。&lt;/li&gt;&#xA;&lt;li&gt;优化了&lt;strong&gt;listitem&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;备忘&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这部份备忘一些基本命令，省得以后又忘惹。&#xA;* &lt;strong&gt;npm install&lt;/strong&gt;：安装依赖。（有时候直接运行会报错，有可能是配置有更新，但是没有安装。设备多没办法~~~）&#xA;* &lt;strong&gt;npm install xxx &amp;ndash;save&lt;/strong&gt;：安装xxx依赖，并且配置会写入&lt;strong&gt;package.json&lt;/strong&gt;文件。&#xA;* &lt;strong&gt;npm install xxx &amp;ndash;save-dev&lt;/strong&gt;：安装xxx依赖，并且配置会写入&lt;strong&gt;package.json&lt;/strong&gt;文件。(注意这些依赖是用在开发中的，比如说&lt;a href=&#34;https://github.com/smooth-code/svgr&#34;&gt;这个插件&lt;/a&gt;只会再开发期间用于转换&lt;strong&gt;svg&lt;/strong&gt;而并不需要打到包中)&#xA;* &lt;strong&gt;npm start&lt;/strong&gt;：运行程序。（debug用，具体的命令配置也在&lt;strong&gt;package.json&lt;/strong&gt;中，可以自己看看）&#xA;* &lt;strong&gt;npm run-script build/yarn build&lt;/strong&gt;：构建应用，构建的结果放在&lt;strong&gt;./build&lt;/strong&gt;目录中。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我知道这些都是最基本的命令，不要吐槽我！真的是备忘而已！！&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Flag&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;新的一年要做的功能是个博客加上评论功能。初步定的技术栈是&lt;strong&gt;Go&lt;/strong&gt;，原因有几个：&#xA;1. 容易部署&#xA;2. 依赖容易维护&#xA;3. 好玩，能做的事情多。&#xA;4. 最重要的是！看完一&lt;strong&gt;Go&lt;/strong&gt;本书！不能白看啊！&lt;/p&gt;&#xA;</description>
      <pubDate>Sat, 19 Jan 2019 16:34:33 +0000</pubDate>
    </item>
    <item>
      <title>Docker搭建笔记</title>
      <link>https://mmmmmax.cn/#list/15c20c55650d035f1bbed09f79f2b8ad</link>
      <description>&lt;h1&gt;Docker搭建笔记&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;最近由于自己的vps又又又又过期了，迫不得已又又又又要重新部署一下自己的blog。&#xA;其实很早之前就想要使用Docker来部署，然而拖延症一直让我拖延到现在。&#xA;这次其实是蹭了朋友的vps用，想了想也不能用自己的糙脚本直接在朋友的vps上用，&#xA;一旦给人家的vps环境搞炸了怎么办，&#xA;而且用的还是node+python这种库一升级连自己都跑不起来的技术写的blog。所以这次下定决心用上Docker，最终的结果还是不错的。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Docker介绍&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;首先贴一个介绍Docker的&lt;a href=&#34;https://yeasy.gitbooks.io/docker_practice/container/attach_exec.html&#34;&gt;教程&lt;/a&gt;, 以下的介绍很多是基于这个教程而来的&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;什么是Docker&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;为啥要用Docker&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Docker具体的优势可以翻阅之前的教程来详细了解，对我个人而言，Docker降低了部署成本。顺便也带来了更好的效率，以及降低了持续交付和部署的成本。（目前并没有感受到- -!）&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Docker的基本概念&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Image&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这个Image就是大家印象中的那个Image，就是某种定制的镜像文件。（比如Debian啥的）另外Docker构建镜像的时候还有个分层的概念，暂时还没有理解到作用，以后又机会在分析吧。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Container&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Container就是一个Image运行起来真正对应到一个进程后的定义。可以类比成&lt;strong&gt;类&lt;/strong&gt;跟&lt;strong&gt;实例&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Docker安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于我的环境是Manjaro跟MacOS，所以运行&lt;strong&gt;pacman -S docker&lt;/strong&gt;或者&lt;strong&gt;brew cask install docker&lt;/strong&gt;就成功安装了，也不需要其他特别的操作。（棒棒！）其他操作系统的安装可以借鉴文首的教程。（总之不会有很多坑就是了！）&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Docker常用命令&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;获取镜像&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # 例如：docker pull ubuntu:18.04&#xA;  docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;运行镜像&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # -i表示交互式 -t表示终端 --rm表示退出容器即删除容器&#xA;  # -d可以让Docker以守护态的形式运行&#xA;  # -p 本地8000端口绑定docker进程80端口&#xA;  docker run -p 8000:80 -i -t --rm ubuntu:18.04 /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;镜像列表&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  docker images&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # docker system df 可以总体查询镜像以及容器的真实占用空间。&#xA;  docker image ls&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;镜像删除&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  docker image rm &amp;lt;镜像&amp;gt;&#xA;  # 什么镜像名，镜像ID都可以用来删除（很贴心有木有）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;容器相关基础操作&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  # 容器列表&#xA;  docker container ls&#xA;&#xA;  docker container stop &amp;lt;容器&amp;gt;&#xA;  docker container start &amp;lt;容器&amp;gt;&#xA;  docker container restart &amp;lt;容器&amp;gt;&#xA;  docker container rm &amp;lt;容器&amp;gt;&#xA;&#xA;  # 清理所有已经stop的容器&#xA;  docker container prune&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;进入容器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果容器最开始以守护态运行，或者另起了一个shell，这个时候如果我们想要再进入这个容器改怎么操作呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  docker  exec -it &amp;lt;镜像&amp;gt; /bin/bash&#xA;  # 其中的参数跟**docker run**的时候的参数意义一致&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;构建镜像&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;构建镜像的方式有几个，但是直推荐用Dockerfile的方式来构建，好处不多说了（如果你是个码农的话）。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Dockerfile是个什么东东？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Dockerfile本身只是一个文本文件，里面包含了构建一个镜像的所有指令。（一目了然有木有！）&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Dockerfile指令&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;指令还有挺多的，基于我写的简单的Dockerfile来描述一下主要的指令。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#xA;# 构建镜像的基础，指明我要构建的镜像基于ubuntu&#xA;FROM ubuntu:18.04&#xA;&#xA;# 环境变量配置&#xA;# release or debug&#xA;ENV ENV_TYPE release&#xA;&#xA;# 复制文件到镜像&#xA;COPY . /root/web_app&#xA;&#xA;# 切换工作路径&#xA;WORKDIR /root/web_app&#xA;&#xA;# 注意环境变量是可以支持展开的（但是注意不支持CMD命令！！！！）&#xA;ENV APP_CONFIG_FILE /root/flask_proj/webapp/instance/env_$ENV_TYPE.py&#xA;&#xA;# 执行命令 建议多换行，并且不建议在Dockerfile里面运行apt-get upgrade&#xA;RUN apt-get update  &amp;amp;&amp;amp; \&#xA;            apt-get install -y git  &amp;amp;&amp;amp; \&#xA;            apt-get install -y python  &amp;amp;&amp;amp; \&#xA;            apt-get install -y python-pip  &amp;amp;&amp;amp; \&#xA;            apt-get install -y python-virtualenv  &amp;amp;&amp;amp; \&#xA;            apt-get install -y nginx  &amp;amp;&amp;amp; \&#xA;            apt-get install -y vim &#xA;&#xA;# 声明暴露出去的端口（如果你觉得你写的代码不够恶心的话，其实可以不暴露这个端口，让镜像的使用者猜就是了。）&#xA;EXPOSE 80&#xA;&#xA;# 容器启动后运行的命令（注意不支持环境变量！！！！）&#xA;CMD [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/root/web_app/auto_setup.sh&amp;quot;] &#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;其他命令&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;VOLUME&lt;/strong&gt;:制定的保存目录挂载为卷。如果有数据库的话，不挂载直接存储在容器运行时里的话，容器删除，数据库也就没了，显然是不合理的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;:作用跟&lt;strong&gt;CMD&lt;/strong&gt;差不多，但是指定了&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;之后就可以把&lt;strong&gt;CMD&lt;/strong&gt;转变成参数了。形式为&lt;ENTRYPOINT&gt;“&lt;CMD&gt;”&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;备忘&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;总结一下整个部署流程&#xA;1. 将写好的Dockerfile放到你的工程目录的跟目录下并进入&#xA;2. 构建镜像 &lt;strong&gt;docker build .&lt;/strong&gt;&#xA;3. 命名镜像 &lt;strong&gt;docker tag &amp;lt;镜像&amp;gt; user/repo:version&lt;/strong&gt;&#xA;4. 上传镜像 &lt;strong&gt;docker push user/repo:version&lt;/strong&gt;&#xA;5. 上你的开发机 &lt;strong&gt;docker run -p 8000:80 -i -t user/repo:version&lt;/strong&gt;&lt;/p&gt;&#xA;</description>
      <pubDate>Mon, 14 Jan 2019 15:09:36 +0000</pubDate>
    </item>
    <item>
      <title>玩玩树莓派——必须要搭建的一些服务</title>
      <link>https://mmmmmax.cn/#list/f5e1ca11f1f0b8e6cddbf62a87fd108d</link>
      <description>&lt;h1&gt;玩玩树莓派——必须要搭建的一些服务&lt;/h1&gt;&#xA;&#xA;&lt;h3&gt;1.搭建Samba实现局域网共享&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sudo apt-get update&lt;/li&gt;&#xA;&lt;li&gt;sudo apt-get install samba samba-common-bin&lt;/li&gt;&#xA;&lt;li&gt;vim /etc/samba/smb.conf&#xA;&lt;code&gt;&#xA;[share]                           #共享文件的名称，将在网络上以此名称显示&#xA;path = /Downloads                 #配置Downloads文件夹为默认&#xA;valid users = root pi             #允许root 和 pi 两个用户访问&#xA;browseable = yes                  #允许浏览                                 &#xA;public = yes                      #共享开放                                      &#xA;writable = yes                    #可写&#xA;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;/etc/init.d/samba restart&lt;/li&gt;&#xA;&lt;li&gt;smbpasswd –a pi&lt;br /&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;vim /etc/rc.local&lt;/li&gt;&#xA;&lt;li&gt;sudo /etc/init.d/samba start&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;2.配置远程下载机&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里主要利用的是一款开源的下载工具&lt;strong&gt;aria2&lt;/strong&gt;，这个下载工具可以说是神器了，可以多线程下载百度网盘的资源，大概能达到1M/s的下载速度。当然我们同样需要搭建一个web服务来支持方便的添加&lt;strong&gt;aria2&lt;/strong&gt;任务。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;安装aria2&#xA;&lt;code&gt;&#xA;sudo apt-get install aria2 –y&#xA;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;为aria2添加配置文件,其中配置文件可以用我的&lt;a href=&#34;https://github.com/PangPangPangPangPang/dotfiles/blob/master/aria2.conf&#34;&gt;file&lt;/a&gt;&#xA;&lt;code&gt;&#xA;sudo mkdir /etc/aria2&#xA;touch /etc/aria2/aria2.session&#xA;vim /etc/aria2/aria2.conf&#xA;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置nginx，nginx是反向代理，应该是每个web开发者应该熟悉的东西了吧。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;建立web目录&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo mkdir /var/www &amp;amp;&amp;amp; sudo mkdir /var/www/html&#xA;sudo chown -R www-data:www-data /var/www/html&#xA;sudo chmod -R 0755 /var/www/html&#xA;#如果这一步有报错的话很有可能是这个目录已经存在了，那进到这个目录下把默认的html文件删掉。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;下载webui-aria2&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo git clone https://github.com/ziahamza/webui-aria2.git /var/www/html/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;完成之后在局域网内访问树莓派的ip应该就可以看到web页面了。并且可以正常的添加链接进行下载啦！&#xA;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6ccb17ably1flc7ycypw2j21h90q2dhl.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置aria2的自启动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/init.d/aria2c &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#! /bin/sh&#xA;# /etc/init.d/aria2c&#xA;### BEGIN INIT INFO&#xA;# Provides: aria2c&#xA;# Required-Start:    $network $local_fs $remote_fs&#xA;# Required-Stop:     $network $local_fs $remote_fs&#xA;# Default-Start:     2 3 4 5&#xA;# Default-Stop:      0 1 6&#xA;# Short-Description: aria2c RPC init script.&#xA;# Description: Starts and stops aria2 RPC services.&#xA;### END INIT INFO&#xA;#VAR&#xA;RUN=&amp;quot;/usr/bin/aria2c&amp;quot;&#xA;ARIA_PID=$(ps ux | awk &#39;/aria2c --daemon=true --enable-rpc/ &amp;amp;&amp;amp; !/awk/ {print $2}&#39;)&#xA;# Carry out specific functions when asked to by the system&#xA;case &amp;quot;$1&amp;quot; in&#xA;start)&#xA;echo &amp;quot;Starting script aria2c &amp;quot;&#xA;if [ -z &amp;quot;$ARIA_PID&amp;quot; ]; then&#xA;  $RUN --daemon=true --enable-rpc=true -D --conf-path=/home/pi/.aria2/aria2.conf&#xA;  echo &amp;quot;Started&amp;quot;&#xA;else&#xA;  echo &amp;quot;aria2c already started&amp;quot;&#xA;fi&#xA;;;&#xA;stop)&#xA;echo &amp;quot;Stopping script aria2c&amp;quot;&#xA;if [ ! -z &amp;quot;$ARIA_PID&amp;quot; ]; then&#xA;  kill $ARIA_PID&#xA;fi&#xA;echo &amp;quot;OK&amp;quot;&#xA;;;&#xA;restart)&#xA;echo &amp;quot;Restarting script aria2c&amp;quot;&#xA;if [ ! -z &amp;quot;$ARIA_PID&amp;quot; ]; then&#xA;  kill $ARIA_PID&#xA;fi&#xA;sleep 3   # TODO:Maybe need to be adjust&#xA;$RUN --daemon=true --enable-rpc=true -D --conf-path=/home/pi/.aria2/aria2.conf&#xA;echo &amp;quot;OK&amp;quot;&#xA;;;&#xA;status)&#xA;if [ ! -z &amp;quot;$ARIA_PID&amp;quot; ]; then&#xA;  echo &amp;quot;The aria2c is running with PID = &amp;quot;$ARIA_PID&#xA;else&#xA;  echo &amp;quot;No process found for aria2c RPC&amp;quot;&#xA;fi&#xA;;;&#xA;*)&#xA;echo &amp;quot;Usage: /etc/init.d/aria2c {start|stop|restart|status}&amp;quot;&#xA;exit 1&#xA;;;&#xA;esac&#xA;exit 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo chmod +x /etc/init.d/aria2c&#xA;apt-get -y install chkconfig&#xA;chkconfig --add aria2c&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这个自启动配置我一直不成功，索性直接在&lt;strong&gt;.bashrc&lt;/strong&gt;里面添加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aria2c -D --conf-path=/etc/aria2/aria2.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
      <pubDate>Fri, 10 Nov 2017 07:51:33 +0000</pubDate>
    </item>
    <item>
      <title>玩玩树莓派——基础环境搭建 </title>
      <link>https://mmmmmax.cn/#list/8908cc467851da37457185aa26c28ff6</link>
      <description>&lt;h1&gt;玩玩树莓派——基础环境搭建&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;之前倒腾树莓派的时候没有做笔记，正好赶上这次要重新部署一下duerOS的环境，索性就重来过，顺便记一个笔记方便之后查阅。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Raspiberry 安装&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;1.正常烧录镜像&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;比较简单，可以在网上找教程，略过。&#xA;贴一个&lt;a href=&#34;https://sspai.com/post/37356&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;2. wifi网络配置&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;首先说一下我的网路配置：有路由器，无网线，没有显示器。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;首先修改&lt;strong&gt;/boot/wpa_supplicant.conf&lt;/strong&gt;文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{&#xA;country=CN&#xA;ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev&#xA;update_config=1&#xA; &#xA;network={&#xA;ssid=&amp;quot;你的无线网络名称（ssid）&amp;quot;&#xA;key_mgmt=WPA-PSK&#xA;psk=&amp;quot;你的wifi密码&amp;quot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我这里的网络是WPA/WPA2加密。&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;3.开启ssh&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;比较简单，在&lt;strong&gt;/boot&lt;/strong&gt;目录下新建空的&lt;strong&gt;ssh&lt;/strong&gt;文件即可。&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;4.ssh登录&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;配置好之后，连接电源开机。在路由器的主页中修找raspiberry的设备，利用其中的ip即可进行ssh登录。&#xA;格式为：&#xA;账户： &lt;em&gt;pi@ip&lt;/em&gt;&#xA;密码： &lt;em&gt;raspiberry&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;5.VNC登录&lt;/h5&gt;&#xA;&#xA;&lt;p&gt;由于我没有独立的显示器，所以需要开启树莓派的VNC服务，树莓派定制的debian内嵌了VNC的服务，只要简单的开启即可。&#xA;ssh之后输入命令：&#xA;sudo raspi-config&#xA;在某一个二级目录中有VNC的选项，开启即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前为止，已经可以正常开发了。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;后记&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;下一篇文章要记录一下如何集成duerOS环境。&#xA;下下一篇要记录一下如何利用树莓派实现一个远程下载机和samba共享。&lt;/p&gt;&#xA;</description>
      <pubDate>Wed, 01 Nov 2017 22:22:10 +0000</pubDate>
    </item>
    <item>
      <title>ReactNative源码解析（一）：RCTUIManager</title>
      <link>https://mmmmmax.cn/#list/e4274968cab4b954545f17719c630244</link>
      <description>&lt;h1&gt;ReactNative源码解析（一）：RCTUIManager&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;主要流程梳理&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;初始化&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;bridge会持有一个uiManager，这个uiManager负责rootView的布局和渲染逻辑。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@implementation RCTBridge (RCTUIManager)&#xA;- (RCTUIManager *)uiManager&#xA;{&#xA;  return [self moduleForClass:[RCTUIManager class]];&#xA;}&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;rootContentView是rootView的子视图，真正负责承载视图的功能。&#xA;rootContentView在bundle加载结束后初始化，初始化过程中uiManager将rootContentView注册成基本视图。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)bundleFinishedLoading:(RCTBridge *)bridge&#xA;{&#xA;// logic code&#xA;  _contentView = &#xA;  [[RCTRootContentView alloc] initWithFrame:self.bounds &#xA;  bridge:bridge &#xA;  reactTag:self.reactTag &#xA;  sizeFlexiblity:_sizeFlexibility];&#xA;// logic code&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[_bridge.uiManager registerRootView:self&#xA; withSizeFlexibility:sizeFlexibility];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在注册rootView之后在uiManager会维护一套shadowViewTree用来跟真正的viewTree做映射，这些shadowView负责用来布局的计算。其实更深层的是内部维护了一套CSSNodeTree来根shadowViewTree做一一对应。接下来会更详细的介绍。&#xA;&amp;gt;从以上的过程，串联了一条如下的关系：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://mmmmmax.cn/uimanager.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;到这里，初始化中有关uiManager基本结束。接下来是渲染的重头戏。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;渲染&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;渲染源头&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;要触发uiManager的渲染有两个主要的方法，一个是通过js端，一个是通过native端。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;//js端触发渲染&#xA;- (void)batchDidComplete&#xA;- //native端触发渲染&#xA;- (void)setNeedsLayout&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这两个均是uiManager的方法。其中&lt;strong&gt;- (void)setNeedsLayout&lt;/strong&gt;由native主动发起渲染。&lt;strong&gt;- (void)batchDidComplete&lt;/strong&gt;是由bridge中的&lt;strong&gt;- (void)handleBuffer:(id)buffer batchEnded:(BOOL)batchEnded&lt;/strong&gt;调用，而这个方法真是js回调native的统一路口。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;渲染过程&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;那么接下来就要开始梳理&lt;strong&gt;RCTUIManager&lt;/strong&gt;这个类了。&#xA;首先梳理native暴露给js的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;//移除rootShadowView以及其subViews&#xA;//在uiBlock移除rootView以及其subViews&#xA;RCT_EXPORT_METHOD(removeRootView:(nonnull NSNumber *)rootReactTag);&#xA;//顾名思义，替换rootView&#xA;RCT_EXPORT_METHOD(replaceExistingNonRootView:(nonnull NSNumber *)reactTag&#xA;                  withView:(nonnull NSNumber *)newReactTag);&#xA;//管理节点位置                  &#xA;RCT_EXPORT_METHOD(manageChildren:(nonnull NSNumber *)containerTag&#xA;                  moveFromIndices:(NSArray&amp;lt;NSNumber *&amp;gt; *)moveFromIndices&#xA;                  moveToIndices:(NSArray&amp;lt;NSNumber *&amp;gt; *)moveToIndices&#xA;                  addChildReactTags:(NSArray&amp;lt;NSNumber *&amp;gt; *)addChildReactTags&#xA;                  addAtIndices:(NSArray&amp;lt;NSNumber *&amp;gt; *)addAtIndices&#xA;                  removeAtIndices:(NSArray&amp;lt;NSNumber *&amp;gt; *)removeAtIndices)&#xA;//添加子视图，注意这个方法只是像shadowViewTree和viewTree中加节点，并没有真正的触发渲染。并且两个tree增加节点的时机也不同。&#xA;RCT_EXPORT_METHOD(setChildren:(nonnull NSNumber *)containerTag&#xA;                  reactTags:(NSArray&amp;lt;NSNumber *&amp;gt; *)reactTags);&#xA;//根据viewName构建shadowView和view并放入各自的tree中。&#xA;RCT_EXPORT_METHOD(createView:(nonnull NSNumber *)reactTag&#xA;                  viewName:(NSString *)viewName&#xA;                  rootTag:(__unused NSNumber *)rootTag&#xA;                  props:(NSDictionary *)props);&#xA;//更新视图props。&#xA;RCT_EXPORT_METHOD(updateView:(nonnull NSNumber *)reactTag&#xA;                  viewName:(NSString *)viewName // not always reliable, use shadowView.viewName if available&#xA;                  props:(NSDictionary *)props)；&#xA;//将对应视图设置成firstResponder。&#xA;RCT_EXPORT_METHOD(focus:(nonnull NSNumber *)reactTag);&#xA;//取消对应视图firstResponder。&#xA;RCT_EXPORT_METHOD(blur:(nonnull NSNumber *)reactTag);&#xA;//获取对应视图点击的坐标系。&#xA;RCT_EXPORT_METHOD(findSubviewIn:(nonnull NSNumber *)reactTag atPoint:(CGPoint)point callback:(RCTResponseSenderBlock)callback);&#xA;//向所给视图分发command事件。&#xA;RCT_EXPORT_METHOD(dispatchViewManagerCommand:(nonnull NSNumber *)reactTag&#xA;                  commandID:(NSInteger)commandID&#xA;                  commandArgs:(NSArray&amp;lt;id&amp;gt; *)commandArgs);&#xA;//获取对应视图坐标。                  &#xA;RCT_EXPORT_METHOD(measure:(nonnull NSNumber *)reactTag&#xA;                  callback:(RCTResponseSenderBlock)callback);&#xA;//获取对应视图相对window坐标。&#xA;RCT_EXPORT_METHOD(measureInWindow:(nonnull NSNumber *)reactTag&#xA;                  callback:(RCTResponseSenderBlock)callback);&#xA;//判断是否为后代视图。&#xA;RCT_EXPORT_METHOD(viewIsDescendantOf:(nonnull NSNumber *)reactTag&#xA;                  ancestor:(nonnull NSNumber *)ancestorReactTag&#xA;                  callback:(RCTResponseSenderBlock)callback);&#xA;//计算视图的相对于某个给定视图的布局&#xA;RCT_EXPORT_METHOD(measureLayout:(nonnull NSNumber *)reactTag&#xA;                  relativeTo:(nonnull NSNumber *)ancestorReactTag&#xA;                  errorCallback:(__unused RCTResponseSenderBlock)errorCallback&#xA;                  callback:(RCTResponseSenderBlock)callback);&#xA;//计算视图相对于父视图的布局。&#xA;RCT_EXPORT_METHOD(measureLayoutRelativeToParent:(nonnull NSNumber *)reactTag&#xA;                  errorCallback:(__unused RCTResponseSenderBlock)errorCallback&#xA;                  callback:(RCTResponseSenderBlock)callback);&#xA;//计算给定rect内某个视图的子视图的布局队列。&#xA;RCT_EXPORT_METHOD(measureViewsInRect:(CGRect)rect&#xA;                  parentView:(nonnull NSNumber *)reactTag&#xA;                  errorCallback:(__unused RCTResponseSenderBlock)errorCallback&#xA;                  callback:(RCTResponseSenderBlock)callback);  &#xA;//截图。&#xA;RCT_EXPORT_METHOD(takeSnapshot:(id /* NSString or NSNumber */)target&#xA;                  withOptions:(NSDictionary *)options&#xA;                  resolve:(RCTPromiseResolveBlock)resolve&#xA;                  reject:(RCTPromiseRejectBlock)reject)；    &#xA;//设置responder，提供给scrollView使用。&#xA;RCT_EXPORT_METHOD(setJSResponder:(nonnull NSNumber *)reactTag&#xA;                  blockNativeResponder:(__unused BOOL)blockNativeResponder)   &#xA;//清理responder。&#xA;RCT_EXPORT_METHOD(clearJSResponder);   &#xA;//配置下一步动画。&#xA;RCT_EXPORT_METHOD(configureNextLayoutAnimation:(NSDictionary *)config&#xA;                  withCallback:(RCTResponseSenderBlock)callback&#xA;                  errorCallback:(__unused RCTResponseSenderBlock)errorCallback)             &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;暴露的方法比较多，我这里只是做一个简单的注释总结，详细请参阅源码。接下来是native端两个最重要的方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;typedef void (^RCTViewManagerUIBlock)(RCTUIManager *uiManager, NSDictionary&amp;lt;NSNumber *, UIView *&amp;gt; *viewRegistry);&#xA;//将对应视图的block添加到队列中，等待_layoutAndMount触发时执行。&#xA;- (void)addUIBlock:(RCTViewManagerUIBlock)block;&#xA;- &#xA;- (void)_layoutAndMount&#xA;{&#xA;  // 在即将渲染前进行最后自定义的uiBlock，即将启用，不深入分析。&#xA;  for (RCTComponentData *componentData in _componentDataByName.allValues) {&#xA;    RCTViewManagerUIBlock uiBlock = [componentData uiBlockToAmendWithShadowViewRegistry:_shadowViewRegistry];&#xA;    [self addUIBlock:uiBlock];&#xA;  }&#xA;&#xA;  //perform layout&#xA;  for (NSNumber *reactTag in _rootViewTags) {&#xA;    RCTRootShadowView *rootView = (RCTRootShadowView *)_shadowViewRegistry[reactTag];&#xA;    //递归执行layout&#xA;    [self addUIBlock:[self uiBlockWithLayoutUpdateForRootView:rootView]];&#xA;    [self _amendPendingUIBlocksWithStylePropagationUpdateForShadowView:rootView];&#xA;  }&#xA;&#xA;  [self addUIBlock:^(RCTUIManager *uiManager, __unused NSDictionary&amp;lt;NSNumber *, UIView *&amp;gt; *viewRegistry) {&#xA;    /**&#xA;     * TODO(tadeu): Remove it once and for all&#xA;     */&#xA;    for (id&amp;lt;RCTComponent&amp;gt; node in uiManager-&amp;gt;_bridgeTransactionListeners) {&#xA;      [node reactBridgeDidFinishTransaction];&#xA;    }&#xA;  }];&#xA;  //真正执行UI队列任务。&#xA;  [self flushUIBlocks];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然&lt;strong&gt;uiBlockWithLayoutUpdateForRootView&lt;/strong&gt;和&lt;strong&gt;_amendPendingUIBlocksWithStylePropagationUpdateForShadowView&lt;/strong&gt;中也有很多细节要梳理。这些东西就交给大家自己梳理吧～&lt;/p&gt;&#xA;</description>
      <pubDate>Mon, 20 Mar 2017 17:52:11 +0000</pubDate>
    </item>
    <item>
      <title>ObjC runtime源码 阅读笔记（三）</title>
      <link>https://mmmmmax.cn/#list/82ae5e9f92908e595f815271a296116b</link>
      <description>&lt;h1&gt;ObjC runtime源码 阅读笔记（三）&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;objc-references.h&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这篇文章主要分析如下两个方法的内部实现。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)&#xA;    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);&#xA;OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)&#xA;    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这两个方法的内部实现就在&lt;strong&gt;objc-references.mm&lt;/strong&gt;中，分别对应如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy);&#xA;extern id _object_get_associative_reference(id object, void *key);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;先上代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// class AssociationsManager manages a lock / hash table singleton pair.&#xA;// Allocating an instance acquires the lock, and calling its assocations() method&#xA;// lazily allocates it.&#xA;&#xA;class AssociationsManager {&#xA;    static spinlock_t _lock;&#xA;    static AssociationsHashMap *_map;               // associative references:  object pointer -&amp;gt; PtrPtrHashMap.&#xA;public:&#xA;    AssociationsManager()   { _lock.lock(); }&#xA;    ~AssociationsManager()  { _lock.unlock(); }&#xA;    &#xA;    AssociationsHashMap &amp;amp;associations() {&#xA;        if (_map == NULL)&#xA;            _map = new AssociationsHashMap();&#xA;        return *_map;&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;根据注释可以看出&lt;strong&gt;AssociationsManager&lt;/strong&gt;管理一个hash表，并且这个表是单例，最后强调了下这个hash表的初始化是一个懒加载的过程。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其实说到底，所有对象的关联属性都是靠这个&lt;strong&gt;AssociationsHashMap&lt;/strong&gt;管理的。�&#xA;贴上代码分析一下：&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {&#xA;    // retain the new value (if any) outside the lock.&#xA;    ObjcAssociation old_association(0, nil);&#xA;    id new_value = value ? acquireValue(value, policy) : nil;&#xA;    {&#xA;        AssociationsManager manager;&#xA;        //associations 即为管理关联对象的Hash表&#xA;        AssociationsHashMap &amp;amp;associations(manager.associations());&#xA;        disguised_ptr_t disguised_object = DISGUISE(object);&#xA;        //正常流程&#xA;        if (new_value) {&#xA;            // break any existing association.&#xA;            AssociationsHashMap::iterator i = associations.find(disguised_object);&#xA;            //判断associatins中是否已经有object对应的ObjectAssociationMap&#xA;            if (i != associations.end()) {&#xA;                // 已经存在的case&#xA;                // secondary table exists&#xA;                ObjectAssociationMap *refs = i-&amp;gt;second;&#xA;                ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);&#xA;                //判断ObjectAssociationMap中是否已经关联key&#xA;                if (j != refs-&amp;gt;end()) {&#xA;                    //已经存在的case，直接替换成new_value&#xA;                    old_association = j-&amp;gt;second;&#xA;                    j-&amp;gt;second = ObjcAssociation(policy, new_value);&#xA;                } else {&#xA;                    //不存在的case，赋予新的key-value pair&#xA;                    (*refs)[key] = ObjcAssociation(policy, new_value);&#xA;                }&#xA;            } else {&#xA;                // 不存在的case&#xA;                // 生成新的ObjectAssociationMap并赋予新的key-value pair&#xA;                // create the new association (first time).&#xA;                ObjectAssociationMap *refs = new ObjectAssociationMap;&#xA;                associations[disguised_object] = refs;&#xA;                (*refs)[key] = ObjcAssociation(policy, new_value);&#xA;                object-&amp;gt;setHasAssociatedObjects();&#xA;            }&#xA;        } else {&#xA;            // setting the association to nil breaks the association.&#xA;            AssociationsHashMap::iterator i = associations.find(disguised_object);&#xA;            if (i !=  associations.end()) {&#xA;                ObjectAssociationMap *refs = i-&amp;gt;second;&#xA;                ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);&#xA;                if (j != refs-&amp;gt;end()) {&#xA;                    old_association = j-&amp;gt;second;&#xA;                    refs-&amp;gt;erase(j);&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    // release the old value (outside of the lock).&#xA;    if (old_association.hasValue()) ReleaseValue()(old_association);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;get和set的处理大同小异，有兴趣的同学可以看一下源码。&lt;/p&gt;&#xA;</description>
      <pubDate>Tue, 01 Nov 2016 19:20:11 +0000</pubDate>
    </item>
    <item>
      <title>ObjC runtime源码 阅读笔记（二）</title>
      <link>https://mmmmmax.cn/#list/3a161cd562a61807e08bdaf05fe34517</link>
      <description>&lt;h1&gt;ObjC runtime源码 阅读笔记（二）&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;今天开始第二篇的阅读笔记，当然还是继续着上一篇的分析&lt;/h2&gt;&#xA;&#xA;&lt;h2&gt;1.objc-private.h&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;紧接着&lt;strong&gt;objc_object&lt;/strong&gt;的就是如下一些很熟悉的结构体，让我们一个一个的分析。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct method_t *Method;&#xA;typedef struct ivar_t *Ivar;&#xA;typedef struct category_t *Category;&#xA;typedef struct property_t *objc_property_t;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果大家以前接触过&lt;strong&gt;objc/runtime.h&lt;/strong&gt;里的api的话一定不会对&lt;strong&gt;Method&lt;/strong&gt;感到陌生，实际上这就真正代表了一个Objective-c中的方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct method_t {&#xA;    SEL name;&#xA;    const char *types;&#xA;    IMP imp;&#xA;&#xA;    struct SortBySELAddress :&#xA;        public std::binary_function&amp;lt;const method_t&amp;amp;,&#xA;                                    const method_t&amp;amp;, bool&amp;gt;&#xA;    {&#xA;        bool operator() (const method_t&amp;amp; lhs,&#xA;                         const method_t&amp;amp; rhs)&#xA;        { return lhs.name &amp;lt; rhs.name; }&#xA;    };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;name：&lt;/strong&gt;很遗憾我并没有看到&lt;strong&gt;SEL&lt;/strong&gt;内部真正的实现，但是可以简单的把&lt;strong&gt;name&lt;/strong&gt;当作一个方法的名字。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;types：&lt;/strong&gt;方法的类型，比如说返回参数类型，入参类型。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;imp：&lt;/strong&gt;可以看成方法的实现。（方法地址？）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;紧接着又是一个熟悉的东东&lt;strong&gt;ivar_t&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct ivar_t {&#xA;    int32_t *offset;&#xA;    const char *name;&#xA;    const char *type;&#xA;    // alignment is sometimes -1; use alignment() instead&#xA;    uint32_t alignment_raw;&#xA;    uint32_t size;&#xA;&#xA;    uint32_t alignment() const {&#xA;        if (alignment_raw == ~(uint32_t)0) return 1U &amp;lt;&amp;lt; WORD_SHIFT;&#xA;        return 1 &amp;lt;&amp;lt; alignment_raw;&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;offset：&lt;/strong&gt;地址偏移量，用来寻找ivar。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;name：&lt;/strong&gt;ivar名称。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;type：&lt;/strong&gt;ivar数据类型。（具体定义可在&lt;strong&gt;runtime.h&lt;/strong&gt;中找到）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;alignment：&lt;/strong&gt;内存偏移量，用于内存对齐。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;size：&lt;/strong&gt;ivar的size。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;上面的两个结构体会作为item组成相应list。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct method_list_t : entsize_list_tt&amp;lt;method_t, method_list_t, 0x3&amp;gt; {&#xA;    bool isFixedUp() const;&#xA;    void setFixedUp();&#xA;&#xA;    uint32_t indexOfMethod(const method_t *meth) const {&#xA;        uint32_t i = &#xA;            (uint32_t)(((uintptr_t)meth - (uintptr_t)this) / entsize());&#xA;        assert(i &amp;lt; count);&#xA;        return i;&#xA;    }&#xA;};&#xA;&#xA;struct ivar_list_t : entsize_list_tt&amp;lt;ivar_t, ivar_list_t, 0&amp;gt; {&#xA;    bool containsIvar(Ivar ivar) const {&#xA;        return (ivar &amp;gt;= (Ivar)&amp;amp;*begin()  &amp;amp;&amp;amp;  ivar &amp;lt; (Ivar)&amp;amp;*end());&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其实这一部分的作用和声明都比较简单。大概理解里面的成员就可以了。&lt;/p&gt;&#xA;</description>
      <pubDate>Fri, 28 Oct 2016 12:35:36 +0000</pubDate>
    </item>
    <item>
      <title>ObjC runtime源码 阅读笔记（一）</title>
      <link>https://mmmmmax.cn/#list/aa83004a4101ba910eabec6e18a98d1b</link>
      <description>&lt;h1&gt;ObjC runtime源码 阅读笔记（一）&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;今天开始记录一系列的阅读笔记，顺便督促一下自己阅读runtime的源码，本文的源码来自于&lt;a href=&#34;http://opensource.apple.com/source/objc4/&#34;&gt;apple opensource&lt;/a&gt;。&lt;/h2&gt;&#xA;&#xA;&lt;h2&gt;1.objc-private.h&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;打开头文件就看到了两个熟悉的结构体指针&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct objc_class *Class;&#xA;typedef struct objc_object *id;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们会经常用到&lt;strong&gt;id&lt;/strong&gt;这个指针，比较老的&lt;strong&gt;Foundation&lt;/strong&gt;框架中，一般的初始化方法都会返回一个&lt;strong&gt;id&lt;/strong&gt;对象，并且一些有iOS编程经验的老鸟也会说&lt;strong&gt;ObjC&lt;/strong&gt;中的所有对象都可以强转成&lt;strong&gt;id&lt;/strong&gt;类型。那么现在就来分析一下&lt;strong&gt;id&lt;/strong&gt;究竟是个什么东东。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从源码来看真的是好长的一坨结构体,首先看到的是一个&lt;strong&gt;isa_t&lt;/strong&gt;的&lt;strong&gt;union&lt;/strong&gt;：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;private:&#xA;    isa_t isa;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个&lt;strong&gt;isa_t&lt;/strong&gt;用一句话概括就是：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对64位的设备对象进行类对象指针的优化，利用合理的bit（arm64设备为32位）存储类对象的地址，其他位用来进行内存管理。这种优化模式被称为&lt;strong&gt;tagged pointer&lt;/strong&gt;。用在&lt;strong&gt;isa_t&lt;/strong&gt;的实现中称作&lt;strong&gt;IndexedIsa&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下面是&lt;strong&gt;isa_t&lt;/strong&gt;在&lt;strong&gt;arm64&lt;/strong&gt;架构下的结构：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;union isa_t &#xA;{&#xA;    uintptr_t bits;&#xA;    &#xA;#   define ISA_MASK        0x00007ffffffffff8ULL&#xA;#   define ISA_MAGIC_MASK  0x001f800000000001ULL&#xA;#   define ISA_MAGIC_VALUE 0x001d800000000001ULL&#xA;    struct {&#xA;        uintptr_t indexed           : 1;&#xA;        uintptr_t has_assoc         : 1;&#xA;        uintptr_t has_cxx_dtor      : 1;&#xA;        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000&#xA;        uintptr_t magic             : 6;&#xA;        uintptr_t weakly_referenced : 1;&#xA;        uintptr_t deallocating      : 1;&#xA;        uintptr_t has_sidetable_rc  : 1;&#xA;        uintptr_t extra_rc          : 19;&#xA;#       define RC_ONE   (1ULL&amp;lt;&amp;lt;45)&#xA;#       define RC_HALF  (1ULL&amp;lt;&amp;lt;18)&#xA;    };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;indexed：标记是否启动指针优化&lt;/li&gt;&#xA;&lt;li&gt;has_assoc：是否有关联对象&lt;/li&gt;&#xA;&lt;li&gt;has&lt;em&gt;cxx&lt;/em&gt;dtor：是否有析构器&lt;/li&gt;&#xA;&lt;li&gt;shiftcls：类对象指针&lt;/li&gt;&#xA;&lt;li&gt;magic：标记初始化完成&lt;/li&gt;&#xA;&lt;li&gt;weakly_refrenced：是否弱引用&lt;/li&gt;&#xA;&lt;li&gt;deallocating：是否正在释放&lt;/li&gt;&#xA;&lt;li&gt;extra_rc：引用计数-1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;至此，优化情况下的isa&lt;em&gt;t包含的内容大体总结完毕。&#xA;回过头来继续分析**objc&lt;/em&gt;object**内的函数。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Class ISA() //不支持tagged pointer时候获取Class的函数&#xA;Class getIsa() //支持tagged pointer时候获取Class的函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面是一系列isa初始化的函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initIsa(Class cls /*indexed=false*/);&#xA;void initClassIsa(Class cls /*indexed=maybe*/);&#xA;void initProtocolIsa(Class cls /*indexed=maybe*/);&#xA;void initInstanceIsa(Class cls, bool hasCxxDtor);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;值得注意的是这几个函数最后调用的都是&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;inline bool objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面的函数是用来改变一个对象的Class：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Class changeIsa(Class newCls);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;印象中KVO的实现中，会改变一个对象的Class，以后会带来验证。&#xA;接下来的一些列函数顾名思义，我也不做解释，内部的实现基本也都是依赖于&lt;strong&gt;isa&lt;/strong&gt;来进行的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    // changeIsa() should be used to change the isa of existing objects.&#xA;    // If this is a new object, use initIsa() for performance.&#xA;    Class changeIsa(Class newCls);&#xA;&#xA;    bool hasIndexedIsa();&#xA;    bool isTaggedPointer();&#xA;    bool isClass();&#xA;&#xA;    // object may have associated objects?&#xA;    bool hasAssociatedObjects();&#xA;    void setHasAssociatedObjects();&#xA;&#xA;    // object may be weakly referenced?&#xA;    bool isWeaklyReferenced();&#xA;    void setWeaklyReferenced_nolock();&#xA;    &#xA;    // object may have -.cxx_destruct implementation?&#xA;    bool hasCxxDtor();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里我解释一下下面这两个方法的区别。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool hasIndexedIsa();&#xA;bool isTaggedPointer();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;本质上这两个函数都是来判断某个指针是否启用了tagged pointer。不同的是&#xA;&lt;strong&gt;bool hasIndexedIsa();&lt;/strong&gt;是用来判断当前对象的&lt;strong&gt;isa&lt;/strong&gt;是否启用&lt;strong&gt;tagged pointer&lt;/strong&gt;，而&lt;strong&gt;bool isTaggedPointer();&lt;/strong&gt;函数用来判断当前的对象指针是否启用了&lt;strong&gt;tagged pointer&lt;/strong&gt;。根据我的调研，比如&lt;strong&gt;NSNumber&lt;/strong&gt;、&lt;strong&gt;NSDate&lt;/strong&gt;等值占用内存比较少的对象启用了&lt;strong&gt;tagged pointer&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来是一系列管理引用计数以及生命周期的函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Optimized calls to retain/release methods&#xA;    id retain();&#xA;    void release();&#xA;    id autorelease();&#xA;    // Implementations of retain/release methods&#xA;    id rootRetain();&#xA;    bool rootRelease();&#xA;    id rootAutorelease();&#xA;    bool rootTryRetain();&#xA;    bool rootReleaseShouldDealloc();&#xA;    uintptr_t rootRetainCount();&#xA;&#xA;    // Implementation of dealloc methods&#xA;    bool rootIsDeallocating();&#xA;    void clearDeallocating();&#xA;    void rootDealloc();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;是不是很熟悉呢？先看一下&lt;strong&gt;id retain()&lt;/strong&gt;的内部实现：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;inline id &#xA;objc_object::retain()&#xA;{&#xA;    // UseGC is allowed here, but requires hasCustomRR.&#xA;    assert(!UseGC  ||  ISA()-&amp;gt;hasCustomRR());&#xA;    assert(!isTaggedPointer());&#xA;&#xA;    if (! ISA()-&amp;gt;hasCustomRR()) {&#xA;        return rootRetain();&#xA;    }&#xA;&#xA;    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;翻译一下，如果使用GC但是并没有custom的retain/release方法则会直接断言掉，如果支持tagged pointer这回直接断言掉。接下来的流程就是如果没有custom的retain/release方法就会调用rootRetain()。兜兜转转最后会调用如下方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&#xA;ALWAYS_INLINE id &#xA;objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#xA;{&#xA;    assert(!UseGC);&#xA;    if (isTaggedPointer()) return (id)this;&#xA;&#xA;    bool sideTableLocked = false;&#xA;    bool transcribeToSideTable = false;&#xA;&#xA;    isa_t oldisa;&#xA;    isa_t newisa;&#xA;&#xA;    do {&#xA;        transcribeToSideTable = false;&#xA;        oldisa = LoadExclusive(&amp;amp;isa.bits);&#xA;        newisa = oldisa;&#xA;        if (!newisa.indexed) goto unindexed;&#xA;        // don&#39;t check newisa.fast_rr; we already called any RR overrides&#xA;        if (tryRetain &amp;amp;&amp;amp; newisa.deallocating) goto tryfail;&#xA;        uintptr_t carry;&#xA;        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;amp;carry);  // extra_rc++&#xA;&#xA;        if (carry) {&#xA;            // newisa.extra_rc++ overflowed&#xA;            if (!handleOverflow) return rootRetain_overflow(tryRetain);&#xA;            // Leave half of the retain counts inline and &#xA;            // prepare to copy the other half to the side table.&#xA;            if (!tryRetain &amp;amp;&amp;amp; !sideTableLocked) sidetable_lock();&#xA;            sideTableLocked = true;&#xA;            transcribeToSideTable = true;&#xA;            newisa.extra_rc = RC_HALF;&#xA;            newisa.has_sidetable_rc = true;&#xA;        }&#xA;    } while (!StoreExclusive(&amp;amp;isa.bits, oldisa.bits, newisa.bits));&#xA;&#xA;    if (transcribeToSideTable) {&#xA;        // Copy the other half of the retain counts to the side table.&#xA;        sidetable_addExtraRC_nolock(RC_HALF);&#xA;    }&#xA;&#xA;    if (!tryRetain &amp;amp;&amp;amp; sideTableLocked) sidetable_unlock();&#xA;    return (id)this;&#xA;&#xA; tryfail:&#xA;    if (!tryRetain &amp;amp;&amp;amp; sideTableLocked) sidetable_unlock();&#xA;    return nil;&#xA;&#xA; unindexed:&#xA;    if (!tryRetain &amp;amp;&amp;amp; sideTableLocked) sidetable_unlock();&#xA;    if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;&#xA;    else return sidetable_retain();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这段代码确实值得仔细研读,转换成伪代码的形式为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ALWAYS_INLINE id &#xA;objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#xA;{&#xA;   if (not support tagged pointer) return this;&#xA;   do {&#xA;       if (isa not support indexed) &#xA;           sidetable_tryRetain(); //利用sidetable进行管理对象的引用计数。 &#xA;       if (isa support indexed)&#xA;           newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;amp;carry);  // extra_rc+&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然内部还有一些力&lt;strong&gt;retry&lt;/strong&gt;已经对于&lt;strong&gt;overflow&lt;/strong&gt;的处理，这篇文章就不做过多的分析。但是大体上对于没有进行&lt;strong&gt;isa&lt;/strong&gt;的&lt;strong&gt;indexed&lt;/strong&gt;优化的对象的引用计数是依赖于&lt;strong&gt;SideTable()&lt;/strong&gt;管理，而进行&lt;strong&gt;indexed&lt;/strong&gt;优化的对象则直接利用&lt;strong&gt;isa&lt;/strong&gt;指针进行管理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来的private函数我就不多做分析了，值得注意的是，里面有很多有关于&lt;strong&gt;sidetable&lt;/strong&gt;的函数，但是这些函数是在&lt;strong&gt;NSObject.mm&lt;/strong&gt;中实现的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样有关于&lt;strong&gt;objc_obejct&lt;/strong&gt;这个结构体的分析就到此为止。接下来还有一系列的文章进行分析。加油！&lt;/p&gt;&#xA;</description>
      <pubDate>Tue, 25 Oct 2016 12:35:36 +0000</pubDate>
    </item>
    <item>
      <title>FMDB阅读笔记（二）</title>
      <link>https://mmmmmax.cn/#list/43f17c6a532a17c48debe47e1e6b832f</link>
      <description>&lt;h1&gt;FMDB阅读笔记（二）&lt;/h1&gt;&#xA;&#xA;&lt;h3&gt;FMDatabase&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;FMDatabase&lt;/strong&gt;作为核心类，封装了sqlite的大部分数据库操作。&#xA;初始化方法没什么可说的，从**- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName;&#xA;**说起。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;####flags&#xA;三个必选项：&lt;strong&gt;SQLITE&lt;em&gt;OPEN&lt;/em&gt;READONLY&lt;/strong&gt;，&lt;strong&gt;SQLITE&lt;em&gt;OPEN&lt;/em&gt;READWRITE&lt;/strong&gt;，&lt;strong&gt;SQLITE&lt;em&gt;OPEN&lt;/em&gt;CREATE&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.sqlite.org/vfs.html&#34;&gt;vfs&lt;/a&gt;&lt;/p&gt;&#xA;</description>
      <pubDate>Tue, 26 Jan 2016 19:36:11 +0000</pubDate>
    </item>
    <item>
      <title>FMDB阅读笔记（一）</title>
      <link>https://mmmmmax.cn/#list/7199547ba88fb585f799e9a6d138cb14</link>
      <description>&lt;h1&gt;FMDB阅读笔记（一）&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;FMDatabaseQueue&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;该类提供了多线程操作数据库的功能。尽量不要在多线程操作同一个&lt;strong&gt;FMDatabase&lt;/strong&gt;实例。取而代之的是在每一个&lt;strong&gt;FMDatabaseQueue&lt;/strong&gt;创建一个&lt;strong&gt;FMDatabase&lt;/strong&gt;实例。下面来详细看代码吧。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags {&#xA;    &#xA;    self = [super init];&#xA;    &#xA;    if (self != nil) {&#xA;        &#xA;        _db = [[[self class] databaseClass] databaseWithPath:aPath];&#xA;        FMDBRetain(_db);&#xA;        &#xA;#if SQLITE_VERSION_NUMBER &amp;gt;= 3005000&#xA;        BOOL success = [_db openWithFlags:openFlags];&#xA;#else&#xA;        BOOL success = [_db open];&#xA;#endif&#xA;        if (!success) {&#xA;            NSLog(@&amp;quot;Could not create database queue for path %@&amp;quot;, aPath);&#xA;            FMDBRelease(self);&#xA;            return 0x00;&#xA;        }&#xA;        &#xA;        _path = FMDBReturnRetained(aPath);&#xA;        &#xA;        _queue = dispatch_queue_create([[NSString stringWithFormat:@&amp;quot;fmdb.%@&amp;quot;, self] UTF8String], NULL);&#xA;        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);&#xA;        _openFlags = openFlags;&#xA;    }&#xA;    &#xA;    return self;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;初始化方法，创建database实例，然后创建了一个串行队列，并用&lt;strong&gt;dispatch&lt;em&gt;queue&lt;/em&gt;set_specific&lt;/strong&gt;方法跟&lt;strong&gt;FMDatabaseQueue&lt;/strong&gt;创建关联。&lt;strong&gt;openWithFlags:openFlags&lt;/strong&gt;为开启文件的选项。默认&lt;strong&gt;open&lt;/strong&gt;方法的选项为&lt;strong&gt;SQLITE&lt;em&gt;OPEN&lt;/em&gt;READWRITE | SQLITE&lt;em&gt;OPEN&lt;/em&gt;CREATE&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)inDatabase:(void (^)(FMDatabase *db))block {&#xA;    /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue&#xA;     * and then check it against self to make sure we&#39;re not about to deadlock. */&#xA;    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);&#xA;    assert(currentSyncQueue != self &amp;amp;&amp;amp; &amp;quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&amp;quot;);&#xA;    &#xA;    FMDBRetain(self);&#xA;    &#xA;    dispatch_sync(_queue, ^() {&#xA;        &#xA;        FMDatabase *db = [self database];&#xA;        block(db);&#xA;        &#xA;        if ([db hasOpenResultSets]) {&#xA;            NSLog(@&amp;quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&amp;quot;);&#xA;            &#xA;#if defined(DEBUG) &amp;amp;&amp;amp; DEBUG&#xA;            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&amp;quot;_openResultSets&amp;quot;] copy]);&#xA;            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) {&#xA;                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];&#xA;                NSLog(@&amp;quot;query: &#39;%@&#39;&amp;quot;, [rs query]);&#xA;            }&#xA;#endif&#xA;        }&#xA;    });&#xA;    &#xA;    FMDBRelease(self);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;利用&lt;strong&gt;dispatch&lt;em&gt;get&lt;/em&gt;specific&lt;/strong&gt;获得&lt;strong&gt;FMDatabaseQueue&lt;/strong&gt;关联的线程，如果是同一个线程，则直接断言，因为同线程执行&lt;strong&gt;dispatch_sync&lt;/strong&gt;会造成死锁。这里的&lt;strong&gt;FMDBRetain(self)&lt;/strong&gt;和&lt;strong&gt;FMDBRelease(self)&lt;/strong&gt;应该是为了防止block内提前将self释放造成后续访问野指针。接下来在关联线程中获取database并执行block，这里如果在database中存在多个查询结果则防处警告，debug模式下会打印出这些查询结果的query。这里的copy操作不理解。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block;&#xA;- (void)inDeferredTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这两个方法的内部逻辑很简单，判断事务开启&lt;strong&gt;defer transaction&lt;/strong&gt; 或者&lt;strong&gt;exclusive transaction&lt;/strong&gt;，关闭时根据业务逻辑&lt;strong&gt;rollback&lt;/strong&gt;或者&lt;strong&gt;commit&lt;/strong&gt;。这个类很简单，就分析到这里。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;FMDatabasePool&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;一开篇就强调不到万不得已不要用这个类，如果你只是用来读数据库，可以用这个类，否则可能造成死锁。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)executeLocked:(void (^)(void))aBlock {&#xA;    dispatch_sync(_lockQueue, aBlock);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该类通过上述方法保证池子操作的线程安全（毕竟已经同步单线程跑了），但是该类并不能保证池内数据库操作安全，该死锁还是会死锁，同时读写会引发很大的问题。这个类没有什么太多值得说的地方，如果有大量并发读操作的需求的话推荐使用这个类，其他都不推荐。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;FMResultSet&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;query结果的类。通过&lt;strong&gt;FMStatement&lt;/strong&gt;访问结果。这个类主要的功能算是提供了一套友好的OC接口来访问结果。&lt;/p&gt;&#xA;</description>
      <pubDate>Fri, 22 Jan 2016 17:30:23 +0000</pubDate>
    </item>
    <item>
      <title>《征服C指针》阅读笔记 II</title>
      <link>https://mmmmmax.cn/#list/b4a05401492c8ff5869cb4fdc2f8449e</link>
      <description>&lt;h1&gt;《征服C指针》阅读笔记 II&lt;/h1&gt;&#xA;&#xA;&lt;h3&gt;第三章 揭秘C的语法&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;3.1 解读C的声明&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这张首先介绍的是如何读C中的声明，让你用英文的语法去理解声明，可能是岛国人民的英语比较烂，声明这里我感觉没那么多坑，容易晕的地方无非就是指针数组和数组指针，简而言之就是** * &lt;strong&gt;和&lt;/strong&gt;变量名&lt;strong&gt;如果有小括号返回的就是指针，否则就是数组。这个问题归根结底就是&lt;/strong&gt; * &lt;strong&gt;的优先级高，就拿&lt;/strong&gt;int *p[10]&lt;strong&gt;来说，&lt;/strong&gt; * &lt;strong&gt;的优先级很高，跟int结合后就决定了返回的是&lt;/strong&gt;int *&lt;strong&gt;而读到最后发现&lt;/strong&gt;[]&lt;strong&gt;，自然而然就变成了&lt;/strong&gt;返回int * 类型的数组&lt;strong&gt;，而如果&lt;/strong&gt;int *&lt;strong&gt;加上小括号变成&lt;/strong&gt;int (*p)[]&lt;strong&gt;，首先返回的会是&lt;/strong&gt;int&lt;strong&gt;,看到&lt;/strong&gt;[]&lt;strong&gt;就知道返回的是&lt;/strong&gt;int数组&lt;strong&gt;,最后&lt;/strong&gt;(*p)&lt;strong&gt;声明&lt;/strong&gt;p**是指针，最终返回的是数组指针，这里个人感觉不要揣测Dennis Ritchie的想法，记住就好，熟而生巧。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;3.2 C的数据类型的模型&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;前半段介绍了一下数组指针的小细节。如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; int arr[10];&#xA; int *p = &amp;amp;arr;&#xA; printf(&amp;quot;size ------- \n arr - %d\n &amp;amp;arr - %d\n p - %d\n&amp;quot;,sizeof(arr), sizeof(&amp;amp;arr), sizeof(p));&#xA; printf(&amp;quot;point ------- \n arr - %p\n &amp;amp;arr - %p\n p - %p\n&amp;quot;,arr, &amp;amp;arr, p);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果为&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;size ------- &#xA; arr - 40&#xA; &amp;amp;arr - 8&#xA; p - 8&#xA;point ------- &#xA; arr - 0x7fff5fbff830&#xA; &amp;amp;arr - 0x7fff5fbff830&#xA; p - 0x7fff5fbff830&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看到最大的差别就是p和[arr]的sizeof不同，影响的地方就是两种类型的指针作自增操作的时候数值不同，两者的运用场景各有不同。这里差别来自于&lt;strong&gt;p&lt;/strong&gt;是**int *&lt;strong&gt;类型而arr是&lt;/strong&gt;int [10]**类型的，编译器会根据不同的类型做自增操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;C中不存在多维数组，只不过是数组的数组&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.2.6介绍了函数指针，总结起来：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从函数类型不能派生出除了指针类型之外的其他任何类型。（原因在于函数类型的大小是不定的，但是函数指针的大小是确定的）&lt;/li&gt;&#xA;&lt;li&gt;从数组类型是不能派生出函数类型的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;3.2.10不完全类型，总结起来：&#xA;C有三种类型：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对象类型（char、int、数组、指针、结构体）&lt;/li&gt;&#xA;&lt;li&gt;函数类型&lt;/li&gt;&#xA;&lt;li&gt;不完全类型，结构体标记的声明就是不完全类型(void 也为不完全类型)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;例子：typedef struct Woman_tag Woman;声明的时候并不知道Woman的大小。&#xA;&lt;strong&gt;结构体中不能存在不完全类型，但是可以存在不完全类型的指针&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;3.3表达式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;略&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;3.4解读C的声明&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;3.4.1介绍了&lt;strong&gt;const&lt;/strong&gt;修饰符，总结：&#xA;跟以前的认识一样，&lt;strong&gt;const&lt;/strong&gt;修饰它右面整体的类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.5介绍了C声明函数的参数不可以有数组，只能传递数组指针，并且重要的是&lt;strong&gt;int a[]&lt;/strong&gt;和&lt;strong&gt;int *a&lt;/strong&gt;等价，但是个人推荐前一种方式，因为前一种更加直观。然后作者倾向于后一种，不解。&lt;/p&gt;&#xA;</description>
      <pubDate>Thu, 31 Dec 2015 11:39:59 +0000</pubDate>
    </item>
    <item>
      <title>《征服C指针》阅读笔记</title>
      <link>https://mmmmmax.cn/#list/309aa9a430dcb3d888f2ad65c61e3590</link>
      <description>&lt;h1&gt;《征服C指针》阅读笔记&lt;/h1&gt;&#xA;&#xA;&lt;h4&gt;缘由&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;上个周末参加了SF的分享会，听了一位来自QQ浏览器的工程师关于iOS内存管理的分享。当初认为iOS上的内存管理不重要，也不会出多大的篓子，基本概念比如引用计数什么的明白原理就好。然而听分享的时候还是云里雾里大概只能听懂70%，回去之后反思了一下，大学时候的c学的就很烂，都是只是会用，如果想精进就必须要明白其中的原理，《征服C指针》这本书以前就听说过，很多同学推荐过，不过大概是大学期间确实玩心太重，不能耐下心来去看这种既不能提高绩点，又不能和当时实习挂钩的书（当年实习的大型机真是荒废了半年多的时光啊）。想那么多，不如现在就开始做，这篇读书笔记一是为了分享，也是为了督促自己。目测会有好几篇。那就开始吧！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;第一章 从基础开始&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;1.1 什么是C&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这一节主要介绍了c的由来，我以前一直以为&lt;strong&gt;sizeof&lt;/strong&gt;只是一个函数，没想到竟然是关键字。太菜了，惭愧惭愧。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;1.2 关于指针&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;不得不说，即使是基础介绍的一章，也涨了姿势。&#xA;这里有指针&lt;strong&gt;a&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果&lt;strong&gt;a&lt;/strong&gt;保存了其他变量的地址，可以说是&lt;strong&gt;a&lt;/strong&gt;指向该地址。&lt;/li&gt;&#xA;&lt;li&gt;*&lt;strong&gt;a&lt;/strong&gt;等同于&lt;strong&gt;a&lt;/strong&gt;指向的变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;疑问：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int a = 5;&#xA;    void *b = &amp;amp;a;&#xA;    b++;&#xA;    printf(&amp;quot;%p\n&amp;quot;,&amp;amp;a);&#xA;    printf(&amp;quot;%lu\n&amp;quot;,sizeof(int));&#xA;    printf(&amp;quot;%p\n&amp;quot;,(int *)b);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我运行上面代码的时候地址加1并没有加4？why？&#xA;结论：因为我声明的无类型指针，系统不知道自加的时候要加多少。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;1.3 关于数组&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;p[i]&lt;/strong&gt;只是*&lt;strong&gt;(p + i)&lt;/strong&gt;的简写。这个结论真是涨姿势了。&lt;strong&gt;[]&lt;/strong&gt;只是一个语法糖而已。&lt;/li&gt;&#xA;&lt;li&gt;使用指针的效率并不会更高。&lt;/li&gt;&#xA;&lt;li&gt;对数组进行值传递的时候，将数组整体整理成结构体成员。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;第二章 C是怎么使用内存的&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;2.1 虚拟地址&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;要点：程序面对的都是虚拟地址空间（这些结论已经有一定了解了）&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;2.2 内存的使用方法&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;全局变量：定义在函数外面的变量都为全局变量&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;static&lt;/strong&gt;：除去声明为静态变量外，全局变量加上&lt;strong&gt;static&lt;/strong&gt; 后限定作用域在源代码文件中。&lt;/li&gt;&#xA;&lt;li&gt;局部变量声明在函数中。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
      <pubDate>Wed, 30 Dec 2015 09:10:11 +0000</pubDate>
    </item>
    <item>
      <title>iOS二维码扫描识别</title>
      <link>https://mmmmmax.cn/#list/26687675804789a50868b77370a7964e</link>
      <description>&lt;h1&gt;iOS二维码扫描识别&lt;/h1&gt;&#xA;&#xA;&lt;h3&gt;前言&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;二维码功能在app中很常用，在iOS7之前iOS的二维码功能通常用&lt;strong&gt;ZXing&lt;/strong&gt;等框架完成。iOS7之后&lt;strong&gt;AVFoundation&lt;/strong&gt;已经支持了原生的二维码扫描功能。这篇文章帮助大家在app中实现此功能，并且会详细的解释一下其中的过程。在开始编码之前，先介绍一下相关的概念。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;概念相关&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;AVCaptureSession&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;熟悉&lt;strong&gt;AVFoundation&lt;/strong&gt;的同学都会知道&lt;strong&gt;AVCaptureSession&lt;/strong&gt;是其中的核心类。&lt;strong&gt;AVCaptureSession&lt;/strong&gt;协调了一个物理设备的输入（input）和输出（output）。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;AVCaptureInput&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;顾名思义，就是上文中&lt;strong&gt;AVCaptureSession&lt;/strong&gt;协调的输入。不过&lt;strong&gt;AVCaptureInput&lt;/strong&gt;是一个虚类不能直接实例化，可以使用其子类。&lt;strong&gt;AVCaptureInput&lt;/strong&gt;有多个接口可以同时承载一种或多种媒体数据，比如可以同时承载音频数据流和视频数据流。本文章使用的输入是&lt;strong&gt;AVCaptureInput&lt;/strong&gt;的子类&lt;strong&gt;AVCaptureDeviceInput&lt;/strong&gt;。&lt;strong&gt;AVCaptureDeviceInput&lt;/strong&gt;提供了利用&lt;strong&gt;AVCaptureDevice&lt;/strong&gt;捕捉流媒体的功能，顾名思义，就是利用这个输入就可以捕捉到二维码并且识别。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;AVCaptureDevice&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;物理设备的一个抽象，具体到设备上比如摄像头，麦克风。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;AVCaptureOutput&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;跟&lt;strong&gt;AVCaptureInput&lt;/strong&gt;相同也是抽象基类，比如说我们看到的视频，听到的音频都是通过它处理输出。&lt;strong&gt;AVCaptureInput&lt;/strong&gt;可以持有一个或多个&lt;strong&gt;AVCaptureConnection&lt;/strong&gt;实例。本文章使用的是其子类&lt;strong&gt;AVCaptureMetadataOutput&lt;/strong&gt;，该类可以捕获从输出中获取的元数据（metadata）。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;AVCaptureConnection&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;本文中没有使用到，但是还是简单介绍一下概念。&lt;strong&gt;AVCaptureConnection&lt;/strong&gt;可以将&lt;strong&gt;AVCaptureInputPort&lt;/strong&gt;和&lt;strong&gt;AVCaptureOutput&lt;/strong&gt;或者&lt;strong&gt;AVCaptureVideoPreviewLayer&lt;/strong&gt;关联起来。本文不需要手动调用这些关联，当利用&lt;strong&gt;AVCaptureSession&lt;/strong&gt;关联输入和输出的时候，这些关联就已经生成。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;开始&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;首先看一下接口文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;@protocol  QRCodeParserDelegate&amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;&#xA;- (void)QRCodeParser:(AVMetadataMachineReadableCodeObject *)object;&#xA;&#xA;@end&#xA;&#xA;typedef NS_ENUM(NSInteger, QRCodeParserStatus) {&#xA;    QRCodeParserStatusPrepare  = 1,&#xA;    QRCodeParserStatusScanning = 2,&#xA;    QRCodeParserStatusStop     = 3&#xA;};&#xA;&#xA;@interface QRCodeParser : NSObject&#xA;&#xA;@property (nonatomic, assign)QRCodeParserStatus status;&#xA;&#xA;- (instancetype)initWithFrame:(CGRect)rect&#xA;                  andDelegate:(UIViewController&amp;lt;QRCodeParserDelegate&amp;gt;*)delegate;&#xA;- (void)stopReading;&#xA;- (void)startReading;&#xA;- (BOOL)initQRScanner;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;QRCodeParserDelegate&lt;/strong&gt;作为识别出二维码的回调。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;QRCodeParserStatus&lt;/strong&gt;parser的状态机，本文没有使用到。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;initWithFrame:andDelegate:&lt;/strong&gt;为parser的初始化方法。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;startReading&lt;/strong&gt;开始扫描。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;stopReading&lt;/strong&gt;停止扫描。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;initQRScanner&lt;/strong&gt;初始化二维码扫描器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;以下是核心部分代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (BOOL)initQRScanner{&#xA;    NSError *error = nil;&#xA;    &#xA;    //1&#xA;    AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];&#xA;    //2&#xA;    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice&#xA;                                                                        error:&amp;amp;error];&#xA;    if (!input || error) {&#xA;        NSLog(@&amp;quot;%@&amp;quot;, [error localizedDescription]);&#xA;        return NO;&#xA;    }&#xA;    //3&#xA;    _captureSession = [AVCaptureSession new];&#xA;    [_captureSession addInput:input];&#xA;    SafeRelease(input);&#xA;    &#xA;    //4&#xA;    _captureMetadataOutput = [AVCaptureMetadataOutput new];&#xA;    [_captureMetadataOutput setRectOfInterest:CGRectMake(0.25, 0.25, 0.5, 0.5)];&#xA;    [_captureSession addOutput:_captureMetadataOutput];&#xA;    &#xA;    //5&#xA;    dispatchQueue = dispatch_queue_create(&amp;quot;QRQueue&amp;quot;, NULL);&#xA;    [_captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue];&#xA;    [_captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]];&#xA;    &#xA;    //6&#xA;    _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession];&#xA;    [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];&#xA;    [_videoPreviewLayer setFrame:_rect];&#xA;    [_ownerVC.view.layer addSublayer:_videoPreviewLayer];&#xA;    &#xA;    //7&#xA;    [_captureSession startRunning];&#xA;    &#xA;    return YES;&#xA;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来一步步解释上述代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;初始化捕捉设备，并且该设备类型为视频设备&lt;strong&gt;AVMediaTypeVideo&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;利用&lt;strong&gt;captureDevice&lt;/strong&gt;生成输入源&lt;strong&gt;AVCaptureDeviceInput&lt;/strong&gt;，从而此输入源交给&lt;strong&gt;AVCaptureSession&lt;/strong&gt;来协调处理。&lt;/li&gt;&#xA;&lt;li&gt;初始化&lt;strong&gt;_captureSession&lt;/strong&gt;协调输入输出，并将输入源&lt;strong&gt;input&lt;/strong&gt;赋值。&lt;/li&gt;&#xA;&lt;li&gt;生成输出源&lt;strong&gt;_captureMetadataOutput&lt;/strong&gt;，并将它付给&lt;strong&gt;AVCaptureSession&lt;/strong&gt;，&lt;strong&gt;rectOfInterest&lt;/strong&gt;表示将输出源可识别的范围控制在一个方形中。&lt;/li&gt;&#xA;&lt;li&gt;注册一个线程，并在该线程中设置&lt;strong&gt;_captureMetadataOutput&lt;/strong&gt;代理为&lt;strong&gt;self&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;初始化&lt;strong&gt;_videoPreviewLayer&lt;/strong&gt;来承载&lt;strong&gt;input&lt;/strong&gt;提供的画面，并将其加在目标视图上。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;接下来实现其&lt;strong&gt;startReading&lt;/strong&gt;，&lt;strong&gt;stopReading&lt;/strong&gt;方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Objective-c&#34;&gt;- (void)startReading{&#xA;    [_captureSession startRunning];&#xA;}&#xA;&#xA;-(void)stopReading{&#xA;    [_captureSession stopRunning];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;扫描二维码之后的回调：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection{&#xA;    for (AVMetadataObject *object in metadataObjects) {&#xA;        if ([[object type] isEqualToString:AVMetadataObjectTypeQRCode]&#xA;            &amp;amp;&amp;amp; [object isKindOfClass:[AVMetadataMachineReadableCodeObject class]]) {&#xA;            [self stopReading];&#xA;            if ([_ownerVC respondsToSelector:@selector(QRCodeParser:)]) {&#xA;                [_ownerVC performSelector:@selector(QRCodeParser:)&#xA;                                 onThread:[NSThread mainThread]&#xA;                               withObject:object&#xA;                            waitUntilDone:YES];&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;需要注意的是该回调触发在后台线程，如果有处理UI相关的操作请在主线程。&#xA;接下来是有关根据二维码图片读取内容和根据内容生成二维码的代码截取：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;@implementation UIImage (QRCodeGenerator)&#xA;&#xA;- (NSString *)QRCodeParserToContent{&#xA;    CIContext *context = [CIContext contextWithOptions:nil];&#xA;    CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode&#xA;                                              context:context&#xA;                                              options:@{CIDetectorAccuracy:CIDetectorAccuracyHigh}];&#xA;    NSMutableString *result = [NSMutableString new];&#xA;    CIImage *ciImage = [CIImage imageWithCGImage:self.CGImage];&#xA;    NSArray *features = [detector featuresInImage:ciImage];&#xA;    if ([features count] &amp;gt; 0) {&#xA;        for (CIQRCodeFeature *feature in features) {&#xA;            [result appendString:feature.messageString];&#xA;        }&#xA;    }else{&#xA;        result = nil;&#xA;    }&#xA;    return result;&#xA;}&#xA;&#xA;+ (UIImage *)createQRForString:(NSString *)qrString&#xA;                     imageSize:(CGSize)imageSize {&#xA;    NSData *stringData = [qrString dataUsingEncoding:NSUTF8StringEncoding];&#xA;    CIFilter *qrFilter = [CIFilter filterWithName:@&amp;quot;CIQRCodeGenerator&amp;quot;];&#xA;    [qrFilter setDefaults];&#xA;    [qrFilter setValue:stringData forKey:@&amp;quot;inputMessage&amp;quot;];&#xA;    [qrFilter setValue:@&amp;quot;M&amp;quot; forKey:@&amp;quot;inputCorrectionLevel&amp;quot;];&#xA;    &#xA;    CIImage *outPutCIImage = qrFilter.outputImage;&#xA;&#xA;    CGImageRef imageRef = [[CIContext contextWithOptions:nil] createCGImage:outPutCIImage&#xA;                                                                   fromRect:outPutCIImage.extent];&#xA;    CGSize size = CGSizeMake(outPutCIImage.extent.size.width,&#xA;                             outPutCIImage.extent.size.height);&#xA;    &#xA;    UIGraphicsBeginImageContextWithOptions(CGSizeMake(size.width * 10.0,&#xA;                                                      size.height * 10.0),&#xA;                                           NO,&#xA;                                           1.0);&#xA;    CGContextRef context = UIGraphicsGetCurrentContext();&#xA;    CGContextSetInterpolationQuality(context, kCGInterpolationNone);&#xA;    CGContextSetAllowsAntialiasing(context, YES);&#xA;    CGAffineTransform trans = CGAffineTransformMakeTranslation(0.0, size.height * 10.0);&#xA;    trans = CGAffineTransformScale(trans, 10.0, -10.0);&#xA;    CGContextConcatCTM(context, trans);&#xA;    CGContextDrawImage(context, CGRectMake(0, 0, size.width, size.height), imageRef);&#xA;    &#xA;    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();&#xA;    UIGraphicsEndImageContext();&#xA;    &#xA;    return result;&#xA;}&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来解释一下上面的代码：&#xA;&lt;strong&gt;QRCodeParserToContent&lt;/strong&gt;方法中，首先创建一个用来渲染&lt;strong&gt;CIImage&lt;/strong&gt;的上下文&lt;strong&gt;context&lt;/strong&gt;，值得注意的是&lt;strong&gt;CIContext&lt;/strong&gt;线程安全，&lt;strong&gt;CIFilter&lt;/strong&gt;非安全。然后创建一个&lt;strong&gt;detector&lt;/strong&gt;用来探测image中得元素，用来获取一个图片中的&lt;strong&gt;CIFeature&lt;/strong&gt;数组，这里&lt;strong&gt;CIDetectorTypeQRCode&lt;/strong&gt;表示&lt;strong&gt;detector&lt;/strong&gt;需要探测的元素为二维码。接下来的代码简洁明了，获取图片中的&lt;strong&gt;CIFeature&lt;/strong&gt;，并将其中的&lt;strong&gt;messageString&lt;/strong&gt;拼接返回。&#xA;&lt;strong&gt;这个方法最低支持到iOS8.0&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;createQRForString:imageSize:&lt;/strong&gt;方法中，利用的核心类是&lt;strong&gt;CIFilter&lt;/strong&gt;，这个&lt;strong&gt;CIFilter&lt;/strong&gt;可以看做是一个滤镜，核心的思路是交给&lt;strong&gt;filter&lt;/strong&gt;一个输入，也就是原图片，然后配置&lt;strong&gt;filter&lt;/strong&gt;的属性，最后获取的&lt;strong&gt;outputImage&lt;/strong&gt;就是加完滤镜的图片。方法中的&lt;strong&gt;imageRef&lt;/strong&gt;就是结果图片。最后利用&lt;strong&gt;CoreGraphics&lt;/strong&gt;中的绘制图片的函数绘制出&lt;strong&gt;UIImage&lt;/strong&gt;。&lt;/p&gt;&#xA;</description>
      <pubDate>Wed, 23 Dec 2015 12:35:36 +0000</pubDate>
    </item>
    <item>
      <title>Auto Layout中的VFL使用教程（译）</title>
      <link>https://mmmmmax.cn/#list/177087000a33e09d06dea2bf90c66be4</link>
      <description>&lt;h1&gt;Auto Layout中的VFL使用教程（译）&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.raywenderlich.com/110393/auto-layout-visual-format-language-tutorial&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Auto Layout的可视格式化语言（以下简称VFL）允许使用者通过ASCII-art格式化字符串定义约束。&#xA;用一行简单的代码，你可以定义多个水平或垂直方向的约束。对比一个一个加约束，这样可以可以节省很多代码量。&#xA;在这个教程中，你可以用VFL做下面这些事情哦：!&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构建水平和垂直的约束&lt;/li&gt;&#xA;&lt;li&gt;在VFL中使用&lt;strong&gt;views&lt;/strong&gt;描述&lt;/li&gt;&#xA;&lt;li&gt;在VFL中使用&lt;strong&gt;metrics&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;strong&gt;layout options&lt;/strong&gt;去关联其他界面元素&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;strong&gt;layout guides&lt;/strong&gt;处理视图的上下边距（译者：比如&lt;strong&gt;UINavigationBar&lt;/strong&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意：建议读者对Auto Layout有充分了解的情况下阅读此文，如果对于Auto Layout不是很熟悉，建议先阅读&lt;a href=&#34;http://www.raywenderlich.com/115440/auto-layout-tutorial-in-ios-9-part-1-getting-started-2&#34;&gt;Auto Layout Tutorial Part 1: Getting Started&lt;/a&gt;和&lt;a href=&#34;http://www.raywenderlich.com/115444/auto-layout-tutorial-in-ios-9-part-2-constraints&#34;&gt;Auto Layout Tutorial Part 2: Constraints&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;准备开始吧！&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;首先下载&lt;a href=&#34;http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Starter.zip&#34;&gt;事例工程&lt;/a&gt;便于教程使用，该工程提供了一个初级网络社交app-&lt;strong&gt;Grapevine&lt;/strong&gt;的基本欢迎页面。在Xcode中运行工程；你将看到如下画面（在模拟器的&lt;strong&gt;Hardware\Rotate Right&lt;/strong&gt;中旋转屏幕）:&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Initial-Screen.png&#34; alt=&#34;welcomepage&#34; /&gt;&#xA;好吧，这个页面真是一团乱，为什么这种情况会发生呢？面对这种情况我们应该怎么做呢？&#xA;当前界面的所有元素都是跟界面的上边缘（top）和左边缘（left）联系的，这是因为它们没有用Auto Layout约束。通过接下来的教程你会让视图看起来更漂亮。&#xA;打开&lt;strong&gt;Main.storyboard&lt;/strong&gt;观察界面元素。注意到这些元素都被设置为在编译期移除Auto Layout约束。你不应该在真实项目中这样使用，但是这会让你节省一些元素的初始化时间。&#xA;接下来，打开&lt;strong&gt;ViewController.swift&lt;/strong&gt;。在顶部，你可以看到在&lt;strong&gt;Main.storyboard&lt;/strong&gt;中跟Interface Builder（IB）视图元素联系的outlet和一些在runtime代替约束的属性。&#xA;这个时候没啥可以说，但是接下来有一大堆跟VFL有关的东西要学！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;VFL语法&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在你开始编写布局和约束之前，你需要有一些关于VFL格式化串的相关知识。&#xA;第一件要知道的事情：VFL格式化串可以分成如下组成：&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/07/VisualFormatLanguageOptionsImage.png&#34; alt=&#34;formatString&#34; /&gt;&#xA;接下来一个一个解释VFL格式化串：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;约束的方向，非必须。可以有以下的值：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;H:表示水平方向。&lt;/li&gt;&#xA;&lt;li&gt;V:表示垂直方向。&lt;/li&gt;&#xA;&lt;li&gt;不指定:Auto Layout默认水平方向。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;和父视图的头部关联，非必须&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;父视图的上边缘和视图的上边缘的距离（垂直方向）&lt;/li&gt;&#xA;&lt;li&gt;父视图的头部边缘和视图的头部边缘的距离（水平方向）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;需要布局的视图，必须。&lt;/li&gt;&#xA;&lt;li&gt;跟另一个视图关联，非必须。&lt;br /&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;和父视图的尾部关联，非必须。&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;父视图的下边缘和视图的下边缘的距离（垂直方向）&lt;/li&gt;&#xA;&lt;li&gt;父视图的尾部边缘和视图的尾部边缘的距离（水平方向）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;另外在上图中还有两个特殊的字符，他们的意思是：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&amp;rdquo;?&amp;rdquo;&lt;/strong&gt;代表在格式化串中非必须。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&amp;rdquo;*&amp;rdquo;&lt;/strong&gt;代表允许在格式化串中出现0次或多次。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;可使用的符号&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;VFL使用一系列符号去描述布局&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;|&lt;/strong&gt; 父视图&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;-&lt;/strong&gt; 标准间距(通常8pt；如果这个代表到父视图边缘的间距可以改变)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;==&lt;/strong&gt; 宽度相等（可被删除）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;-20-&lt;/strong&gt; 不标准间距（20pt）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&amp;lt;=&lt;/strong&gt; 小于等于&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&amp;gt;=&lt;/strong&gt; 大于等于&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;@250&lt;/strong&gt; 约束权重；可以为0到1000得任意值&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;250 - 低权重&lt;/li&gt;&#xA;&lt;li&gt;750 - 高权重&lt;/li&gt;&#xA;&lt;li&gt;1000 - 绝对权重&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;格式化串实例&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  H:|-[icon(==iconDate)]-20-[iconLabel(120@250)]-20@750-[iconDate(&amp;gt;=50)]-|&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来一步一步解释这个串：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;H: 水平方向。&lt;/li&gt;&#xA;&lt;li&gt;|-[icon icon的头边缘和父视图有一个标准间距。&lt;/li&gt;&#xA;&lt;li&gt;==iconDate icon的宽度应该和iconDate的宽度相等。&lt;/li&gt;&#xA;&lt;li&gt;]-20-[iconLabel icon的尾边缘和iconLabel的头边缘有20pt的距离。&lt;/li&gt;&#xA;&lt;li&gt;[iconLabel(120@250)]iconLabel有一个120pt的宽度，设置成低权重，如果出现冲突Auto Layout会打破这条约束。&lt;/li&gt;&#xA;&lt;li&gt;-20@750- iconLabel的的尾边缘和iconDate的头边缘有20pt的距离，设置成高权重，如果出现冲突Auto Layout不会打破这条约束。&lt;/li&gt;&#xA;&lt;li&gt;[iconDate(&amp;gt;=50)] iconDate的宽度应该大于等于50pt。&lt;/li&gt;&#xA;&lt;li&gt;-| iconDate的尾边缘和父视图的尾边缘有一个标准间距。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/08/got_it.png&#34; alt=&#34;good&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在你对VFL已经有了一个基本的认识&amp;ndash;接下来就要把这些知识用到实际应用中了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;创建约束&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Apple在&lt;strong&gt;NSLayoutConstraint&lt;/strong&gt;提供了类方法&lt;strong&gt;constraintsWithVisualFormat&lt;/strong&gt;去创建约束。你将在&lt;strong&gt;Grapevine&lt;/strong&gt;程序化的创建约束&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Xcode中打开&lt;strong&gt;ViewController.swift&lt;/strong&gt;，并且添加如下代码到&lt;strong&gt;viewDidLoad()&lt;/strong&gt;中：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;appImageView.hidden = true&#xA;welcomeLabel.hidden = true&#xA;summaryLabel.hidden = true&#xA;pageControl.hidden = true &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这些代码会隐藏除了&lt;strong&gt;iconImageView&lt;/strong&gt;，&lt;strong&gt;appNameLabel&lt;/strong&gt;和&lt;strong&gt;skipButton&lt;/strong&gt;之外的元素。运行工程；你会看到如下：&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Hidden-Icons.png&#34; alt=&#34;good&#34; /&gt;&#xA;棒！你现在已经清除了烦人的元素了，现在在&lt;strong&gt;viewDidLoad()&lt;/strong&gt;添加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 1&#xA;let views = [&amp;quot;iconImageView&amp;quot;: iconImageView,&#xA;  &amp;quot;appNameLabel&amp;quot;: appNameLabel,&#xA;  &amp;quot;skipButton&amp;quot;: skipButton]&#xA; &#xA;// 2&#xA;var allConstraints = [NSLayoutConstraint]()&#xA; &#xA;// 3&#xA;let iconVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-20-[iconImageView(30)]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += iconVerticalConstraints&#xA; &#xA;// 4&#xA;let nameLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-23-[appNameLabel]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += nameLabelVerticalConstraints&#xA; &#xA;// 5&#xA;let skipButtonVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-20-[skipButton]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += skipButtonVerticalConstraints&#xA; &#xA;// 6&#xA;let topRowHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-15-[iconImageView(30)]-[appNameLabel]-[skipButton]-15-|&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += topRowHorizontalConstraints&#xA; &#xA;// 7&#xA;NSLayoutConstraint.activateConstraints(allConstraints)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来一步步解释上面的代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建一个字典，这个字典用字符串和view对应，用来在格式化串中使用。&lt;/li&gt;&#xA;&lt;li&gt;创建一个约束数组，你会在接下来的代码中向里面添加约束。&lt;/li&gt;&#xA;&lt;li&gt;创建&lt;strong&gt;iconImageView&lt;/strong&gt;的垂直约束，距父视图的上边缘20pt，本身高度30pt。&lt;/li&gt;&#xA;&lt;li&gt;创建&lt;strong&gt;appNameLabel&lt;/strong&gt;的垂直约束，距父视图的上边缘23pt。&lt;/li&gt;&#xA;&lt;li&gt;创建&lt;strong&gt;skipButton&lt;/strong&gt;的垂直约束，距父视图的上边缘20pt。&lt;/li&gt;&#xA;&lt;li&gt;设置上面三个元素的水平约束，&lt;strong&gt;iconImageView&lt;/strong&gt;的头边缘距父视图的头边缘8pt，宽度30pt。接下来，&lt;strong&gt;iconImageView&lt;/strong&gt;的尾边缘距&lt;strong&gt;appNameLabel&lt;/strong&gt;头边缘8pt，&lt;strong&gt;appNameLabel&lt;/strong&gt;的尾边缘距&lt;strong&gt;skipButton&lt;/strong&gt;的头边缘8pt，最后&lt;strong&gt;skipButton&lt;/strong&gt;的尾边缘距离父视图的尾边缘15pt。&lt;/li&gt;&#xA;&lt;li&gt;用&lt;strong&gt;NSLayoutConstraint&lt;/strong&gt;的类方法&lt;strong&gt;activateConstraints(_:)&lt;/strong&gt;启用约束。在这个步骤你需要添加&lt;strong&gt;allConstraints&lt;/strong&gt;数组。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意：在views字典中的key必须在格式化串中得view串匹配。如果没有，Auto Layout将不能找到引用并且在runtime崩溃。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;运行工程，元素现在看起来怎么样？&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Horizontal-Layout.png&#34; alt=&#34;good&#34; /&gt;&#xA;哈哈，看看是不是已经变得好看多了？&#xA;现在把它放着，这不过是个前戏（误）。你还要有一大坨代码要写呢，但是到最后这些都是值得的。&#xA;接下来，你需要给剩下的元素布局，首先，你需要把最开始加到&lt;strong&gt;viewDidLoad()&lt;/strong&gt;的代码去掉。不要有怨言，删除下面这些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#x9;appImageView.hidden = true&#xA;&#x9;welcomeLabel.hidden = true&#xA;&#x9;summaryLabel.hidden = true&#xA;&#x9;pageControl.hidden = true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样最开始隐藏的元素就又出现了。&#xA;接下来，把当前的&lt;strong&gt;views&lt;/strong&gt;替换成如下的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let views = [&amp;quot;iconImageView&amp;quot;: iconImageView,&#xA; &amp;quot;appNameLabel&amp;quot;: appNameLabel,&#xA; &amp;quot;skipButton&amp;quot;: skipButton,&#xA; &amp;quot;appImageView&amp;quot;: appImageView,&#xA; &amp;quot;welcomeLabel&amp;quot;: welcomeLabel,&#xA; &amp;quot;summaryLabel&amp;quot;: summaryLabel,&#xA; &amp;quot;pageControl&amp;quot;: pageControl]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在你已经为&lt;strong&gt;appImageView&lt;/strong&gt;，&lt;strong&gt;welcomeLabel&lt;/strong&gt;，&lt;strong&gt;summaryLabel&lt;/strong&gt;和&lt;strong&gt;pageControl&lt;/strong&gt;添加了视图定义，这些都可以在VFL格式化串中使用。&#xA;在&lt;strong&gt;activateConstraints()&lt;/strong&gt;调用之前，在&lt;strong&gt;viewDidLoad()&lt;/strong&gt;中添加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 1&#xA;let summaryHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-15-[summaryLabel]-15-|&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += summaryHorizontalConstraints&#xA; &#xA;let welcomeHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-15-[welcomeLabel]-15-|&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += welcomeHorizontalConstraints&#xA; &#xA;// 2&#xA;let iconToImageVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[iconImageView]-10-[appImageView]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += iconToImageVerticalConstraints&#xA; &#xA;// 3&#xA;let imageToWelcomeVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[appImageView]-10-[welcomeLabel]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += imageToWelcomeVerticalConstraints&#xA; &#xA;// 4&#xA;let summaryLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[welcomeLabel]-4-[summaryLabel]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += summaryLabelVerticalConstraints&#xA; &#xA;// 5&#xA;let summaryToPageVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[summaryLabel]-15-[pageControl(9)]-15-|&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += summaryToPageVerticalConstraints &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来一步步解释上面的代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建&lt;strong&gt;summaryLabel&lt;/strong&gt;和&lt;strong&gt;welcomeLabel&lt;/strong&gt;的水平约束，让它们的头边缘和尾边缘分别距父视图的头边缘和尾边缘15pt。&lt;/li&gt;&#xA;&lt;li&gt;创建icon和app image的垂直约束，两者距离10pt。&lt;/li&gt;&#xA;&lt;li&gt;创建app image和welcome label的垂直约束，两者距离10pt。&lt;/li&gt;&#xA;&lt;li&gt;创建welcome label和summary label的垂直约束，两者距离4pt。&lt;/li&gt;&#xA;&lt;li&gt;创建summary label和page control的垂直约束，两者相距15pt，并且page control高度为9pt，和父视图的底边缘距离15。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;运行工程；这些元素看起来怎么样？&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Layout-Before-Options.png&#34; alt=&#34;good&#34; /&gt;&#xA;现在看起来还不错了哦。错，其中的一些元素的布局是正确的，然后，有些并没有，image和page control并没有居中！&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/07/No-Center-RageMakger.png&#34; alt=&#34;bad&#34; /&gt;&#xA;不要害怕，下一节将会告诉你更多关于布局的工具。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Layout Options&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Layout Options提供了一个让你在定义约束的时候对视图进行垂线方向上的约束。&#xA;使用&lt;strong&gt;NSLayoutFormatOptions.AlignAllCenterY&lt;/strong&gt;是一个使用Layout Options的例子，它可以让view在创建水平约束的时候同时让垂直方向居中。&#xA;如果你不想让水平布局的时候垂直方向都居中，而是边对边的话，那就不应该用这个选项。&#xA;接下来，让我们看看Layout Options在创建约束的时候是多么有用。移除&lt;strong&gt;viewDidLoad()&lt;/strong&gt;中如下的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let nameLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-23-[appNameLabel]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += nameLabelVerticalConstraints&#xA; &#xA;let skipButtonVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-20-[skipButton]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;allConstraints += skipButtonVerticalConstraints&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;你刚刚移除了&lt;strong&gt;appNameLabel&lt;/strong&gt;和&lt;strong&gt;skipButton&lt;/strong&gt;的垂直布局。作为替代，你将用Layout Options去给它们添加垂直约束。&#xA;找到创建&lt;strong&gt;topRowHorizontalConstraints&lt;/strong&gt;的代码并且设置&lt;strong&gt;options&lt;/strong&gt;为&lt;strong&gt;[.AlignAllCenterY]&lt;/strong&gt;。看起来是这个样子的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let topRowHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-15-[iconImageView(30)]-[appNameLabel]-[skipButton]-15-|&amp;quot;,&#xA;  options: [.AlignAllCenterY],&#xA;  metrics: nil,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加&lt;strong&gt;NSLayoutFormatOption .AlignAllCenterY&lt;/strong&gt;对上面格式化串中的所有视图都有效，并且创建了一个它们垂直方向中心的约束。如果&lt;strong&gt;iconImageView&lt;/strong&gt;提前创建了包含高度的垂直约束也是有效的。因此，&lt;strong&gt;appNameLabel&lt;/strong&gt;和&lt;strong&gt;skipButton&lt;/strong&gt;同&lt;strong&gt;iconImageView&lt;/strong&gt;一样垂直居中。&#xA;如果你现在运行，布局看起来可能没有改变，但是代码变得更棒了。移除创建&lt;strong&gt;welcomeHorizontalConstraints&lt;/strong&gt;和将它放进数组的代码。这样就移除了&lt;strong&gt;welcomeLabel&lt;/strong&gt;的水平约束。接下来，更新创建&lt;strong&gt;summaryLabelVerticalConstraints&lt;/strong&gt;的Layout Options：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;summaryLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&amp;quot;V:[welcomeLabel]-4-[summaryLabel]&amp;quot;,&#xA;options: [.AlignAllLeading, .AlignAllTrailing],&#xA;metrics: nil,&#xA;views: views);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个代码增加了&lt;strong&gt;NSLayoutFormatOptions&lt;/strong&gt;的&lt;strong&gt;.NSLayoutFormatOptions&lt;/strong&gt;和&lt;strong&gt;.AlignAllTrailing&lt;/strong&gt;，&lt;strong&gt;welcomeLabel&lt;/strong&gt;和&lt;strong&gt;summaryLabel&amp;rsquo;s&lt;/strong&gt;的头边缘和尾边缘会距离它们的父视图的边缘15pt。由于提前为&lt;strong&gt;summaryLabel&lt;/strong&gt;定义了水平约束，所以上述代码才会有效。虽然上面的代码带来的是同样的效果，但是实现起来更加优雅了。&#xA;接下来，更新你在创建&lt;strong&gt;summaryToPageVerticalConstraints&lt;/strong&gt;时候的选项：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let pageControlVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[summaryLabel]-15-[pageControl(9)]-15-|&amp;quot;,&#xA;  options: [.AlignAllCenterX],&#xA;  metrics: nil,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就添加了沿x轴中心对齐。同样为&lt;strong&gt;imageToWelcomeVerticalConstraints&lt;/strong&gt;添加选项：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageToWelcomeVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[appImageView]-10-[welcomeLabel]&amp;quot;,&#xA;  options: [.AlignAllCenterX],&#xA;  metrics: nil,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行工程，看看发生了什么？&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-SublayoutViewHeights.png&#34; alt=&#34;perfect&#34; /&gt;&#xA;感觉都居中了是吧？Layout Options让你做出了一个更棒的交互界面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###NSLayoutFormat选项快速参考&#xA;下面是在&lt;strong&gt;Grapevine&lt;/strong&gt;中使用过的属性：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllCenterX&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeCenterX&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllCenterY&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeCenterY&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllLeading&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeLeading&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllTrailing&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeTrailing&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;（译者：由于有些种类的文字是从右到左书写的，所以它们的&lt;strong&gt;.AlignAllLeading&lt;/strong&gt;等价于&lt;strong&gt;.AlignAllRight&lt;/strong&gt;，而对于中文来说，&lt;strong&gt;.AlignAllLeading&lt;/strong&gt;等价于&lt;strong&gt;.AlignAllLeft&lt;/strong&gt;）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是剩余的一些属性：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllLeft&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeLeft&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllRight&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeRight&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllTop&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeBottom&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllBottom&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeCenterX&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;.AlignAllBaseline&lt;/strong&gt; &amp;ndash;使用&lt;strong&gt;NSLayoutAttributeBaseline&lt;/strong&gt;的对齐元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;你同样可以在&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/#//apple_ref/c/tdef/NSLayoutFormatOptions&#34;&gt;文档&lt;/a&gt;详细查看。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;** 注意：为了让Layout Options有效，至少要有一个元素定义过垂直方向的约束。看下面的例子：**&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;   NSLayoutConstraints.constraintsWithVisualFormat(&#xA;     &amp;quot;V:[topView]-[middleView]-[bottomView]&amp;quot;,&#xA;     options: [.AlignAllLeading],&#xA;     metrics: nil,&#xA;     views: [&amp;quot;topView&amp;quot;: topView, &amp;quot;middleView&amp;quot;: middleView, &amp;quot;bottomView&amp;quot;:&amp;quot;bottomView&amp;quot;])     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;** &lt;strong&gt;topView&lt;/strong&gt;，&lt;strong&gt;middleView&lt;/strong&gt;或者&lt;strong&gt;bottomView&lt;/strong&gt;其中一个必须要有一个约束来布局它们的头缘，这样Auto Layout才会正确的产生正确的约束。**&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;接下来学习新的概念！&lt;strong&gt;Metrics&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Metrics&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Metrics是一个能在VFL格式化串中出现的以number为value的字典。如果你需要让距离变得标准化或者有些距离需要计算所以不能直接放在格式化串中的话，Metrics将会变得非常有用！&#xA;将如下常量声明在&lt;strong&gt;ViewController.swift&lt;/strong&gt;的变量之上：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// MARK: - Constants&#xA;private let horizontalPadding: CGFloat = 15.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在你有了一个用于padding的常量，你可以创建一个metrics字典并且将这个常量使用进去。将如下代码添加到&lt;strong&gt;views&lt;/strong&gt;声明的上面：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let metrics = [&amp;quot;hp&amp;quot;: horizontalPadding,&#xA;  &amp;quot;iconImageViewWidth&amp;quot;: 30.0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的代码创建的字典中的key可以再格式化串中使用。&#xA;接下来，用如下代码代替&lt;strong&gt;topRowHorizontalConstraints&lt;/strong&gt;和&lt;strong&gt;summaryHorizontalConstraints&lt;/strong&gt;的定义：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let horizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-hp-[iconImageView(iconImageViewWidth)]-[appNameLabel]-[skipButton]-hp-|&amp;quot;,&#xA;  options: [.AlignAllCenterY],&#xA;  metrics: metrics,&#xA;  views: views)&#xA; &#xA;let summaryHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;H:|-hp-[summaryLabel]-hp-|&amp;quot;,&#xA;  options: [],&#xA;  metrics: metrics,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在你已经将格式化串中得硬代码用metrics字典中keys代替掉了。&#xA;Auto Layout可以进行串替换，将metrics字典中的value替换到格式化串中的key。所以最终，&lt;strong&gt;hp&lt;/strong&gt;将会被替换成15pt，&lt;strong&gt;iconImageViewWidth&lt;/strong&gt;将会被替换成30pt。&#xA;你将一个重复出现的莫名其妙的数字变成了一个优雅的变量。如果你想要改变padding，现在就只需要做一件事了。这不是更好吗？metrics字典并不仅限制于常量；如果你需要在runtime期间进行计算，同样可以把这种变量放到metrics中。&#xA;最后的一点小问题是如果你想把这些元素放进&lt;strong&gt;UINavigationController&lt;/strong&gt;或者&lt;strong&gt;UITabBarController&lt;/strong&gt;中，那该怎么办呢？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Layout Guides&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;视图控制器有两个可用的Layout Guides：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;topLayoutGuide&lt;/li&gt;&#xA;&lt;li&gt;bottomLayoutGuide&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;它们都指定了试图控制器的视图中顶部或者底部导航栏边缘的位置，但是在&lt;strong&gt;Grapevine&lt;/strong&gt;中，唯一的导航栏边缘是从状态栏开始的。&#xA;更新&lt;strong&gt;iconVerticalConstraints&lt;/strong&gt;的声明代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let verticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:|-[iconImageView(30)]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样你就把状态栏和&lt;strong&gt;iconImageView&lt;/strong&gt;之间的20pt的距离移除了，运行代码：&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Without-20pts.png&#34; alt=&#34;remove&#34; /&gt;&#xA;现在你的状态栏覆盖掉了视图上的一些元素。在横屏模式时，iOS为了给小屏幕设备提供更多的有效空间移除状态栏，这样&lt;strong&gt;iconImageView&lt;/strong&gt;会紧靠在屏幕的上方。&#xA;使用&lt;strong&gt;topLayoutGuide&lt;/strong&gt;将会解决这种问题，用如下代码代替&lt;strong&gt;views&lt;/strong&gt;字典：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  let views: [String: AnyObject] = [&amp;quot;iconImageView&amp;quot;: iconImageView,&#xA;    &amp;quot;appNameLabel&amp;quot;: appNameLabel,&#xA;    &amp;quot;skipButton&amp;quot;: skipButton,&#xA;    &amp;quot;appImageView&amp;quot;: appImageView,&#xA;    &amp;quot;welcomeLabel&amp;quot;: welcomeLabel,&#xA;    &amp;quot;summaryLabel&amp;quot;: summaryLabel,&#xA;    &amp;quot;pageControl&amp;quot;: pageControl,&#xA;    &amp;quot;topLayoutGuide&amp;quot;: topLayoutGuide,&#xA;    &amp;quot;bottomLayoutGuide&amp;quot;: bottomLayoutGuide]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这次增加了&lt;strong&gt;topLayoutGuide&lt;/strong&gt;和&lt;strong&gt;bottomLayoutGuide&lt;/strong&gt;，它们继承自&lt;strong&gt;UILayoutSupport&lt;/strong&gt;，比不是&lt;strong&gt;UIView&lt;/strong&gt;。&#xA;接下来，就可以使用layout guides去对齐界面元素了。更新&lt;strong&gt;iconVerticalConstraints&lt;/strong&gt;的声明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let verticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&#xA;  &amp;quot;V:[topLayoutGuide]-[iconImageView(30)]&amp;quot;,&#xA;  options: [],&#xA;  metrics: nil,&#xA;  views: views)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来运行工程，完美！&lt;br /&gt;&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/09/Grapevine-Final.png&#34; alt=&#34;PERFECT&#34; /&gt;&#xA;现在你的顶部的界面元素都依赖着&lt;strong&gt;topLayoutGuide&lt;/strong&gt;布局并且无论在横屏或者竖屏模式下状态栏的展现都控制着布局。&#xA;在这一节，你已经学会了当界面存在状态栏的时候如何利用&lt;strong&gt;topLayoutGuide&lt;/strong&gt;来控制界面元素的布局。如果你的视图控制器在&lt;strong&gt;UINavigationController&lt;/strong&gt;中，&lt;strong&gt;topLayoutGuide&lt;/strong&gt;将会包含状态栏和&lt;strong&gt;UINavigationBar&lt;/strong&gt;的状态。同时，如果你的试图控制器在&lt;strong&gt;UITabBarController&lt;/strong&gt;中，&lt;strong&gt;bottomLayoutGuide&lt;/strong&gt;将会提供底部边缘的状态。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;限制&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;VFL让你用一行代码写出了多个约束，大大降低了手指的负担。但是对于当前的实现，还存在一些限制；还有一些重要的东西需要理解。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;视图中心&lt;/li&gt;&#xA;&lt;li&gt;使用约束中的Multiplier&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;视图中心&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在&lt;strong&gt;Grapevine&lt;/strong&gt;中，你用了&lt;strong&gt;.AlignAllCenterY&lt;/strong&gt;和&lt;strong&gt;.AlignAllCenterX&lt;/strong&gt;。&#xA;使用这些表示你让一些视图和其他的一些视图的垂直中心或者水平中心对齐，然而只有在这些视图中存在已经有足够约束能够确定它们的水平和垂直中心位置的时候才能变得有效。&#xA;即使现在通过VFL你可以用一些小把戏来处理中心视图，但是这也不保证在将来的版本中依然有效。&#xA;&lt;img src=&#34;https://koenig-media.raywenderlich.com/uploads/2015/08/constraints_constraining.png&#34; alt=&#34;CONSTRAIN&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####使用约束中的Multiplier&#xA;通过Multiplier，你可以通过比例来对视图进行布局，比如你可以让一个label的宽度是它父视图的60%。由于VFL会同时创建多个没有名字的约束，所以不能通过格式化串来设置百分比系数。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;** 注意：你可以通过&lt;strong&gt;constraintsWithVisualFormat&lt;/strong&gt;返回的数组来遍历约束，但是你需要去确定它们的&lt;strong&gt;NSLayoutAttribute&lt;/strong&gt;属性，这样才能正确的设定Multiplier，但即使是这样，你依然需要替换这些约束，因为约束的Multiplier是不可变的。**&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;现在要干什么？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;你可以下载完整的&lt;a href=&#34;http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Final.zip&#34;&gt;工程&lt;/a&gt;。&#xA;&amp;gt;** 注意：如果你有多个工程使用相同的bundle id，Xcode可能会出现问题。所以如果你完成了这个教程并且想最后运行一下刚才下载的工程，你可以使用&lt;strong&gt;shift+option+command+K&lt;/strong&gt;清空一下build目录。**&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在你已经知道VFL如何工作啦，你已经可以在你的界面中使用这种布局咯。&#xA;你已经知道了如何使用layout options 来减少需要定义的约束。你也已经知道如何使用metrics来在runtime定义距离而不仅仅是编译期。最后，你也知道了VFL的一些限制，但是利大于弊，你应该好好的利用它。&#xA;如果你对该教程或者Auto Layout有什么问题或者建议的话，请留言！&lt;/p&gt;&#xA;</description>
      <pubDate>Fri, 11 Dec 2015 14:12:37 +0000</pubDate>
    </item>
  </channel>
</rss>